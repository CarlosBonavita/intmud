# Quantas instruções uma função chamada pelo programa pode
# executar antes do controle retornar ao programa
exec = 5000

# Se deve abrir uma janela de texto - variável telatxt
telatxt = 1

# Erros em blocos de instruções:
# 0=ignorar, 1=permitir apenas FimSe sem Se, 2=checar tudo
err = 1

# Permitir executar ffplay seguido de um texto qualquer
arqexec = ffplay *

classe _serv
# Lista de endereços mais usados
const inter = "t intervox.nce.ufrj.br 1963"
const interp = "p intervox.nce.ufrj.br 1963"
const dosvox = "p sitiodosvox.com 1963"
const val = "t mud.valinor.com.br 4000"
const myth = "t mud.mythserver.com 4000"
const sim = "t mud.simauria.org 23"
const dentin = "t dentinmud.org 3010"
const turf = "t turf.org 4000"
const lo = "t localhost 1963"
const t2t = "t t2tmud.org 9999"
const t2s = "s t2tmud.org 444"


classe tela
telatxt tela
socket sock
inttempo inic
int1 eco
int8 proto # 0=Telnet, 1=Telnet seguro, 2=Papovox
int8 passo # Passo, ao conectar; depende do protocolo
const msg = tela.msg(arg0)
textotxt hist_texto
textopos hist_pos
arqexec msp_ffplay # Para verificar se o programa ffplay pode ser executado
int8 msp_ativo # 0=precisa verificar ffplay, 1=desativado, 2=ativado
txt100 msp_diretorio # Aonde estão os sons
txt200 msp_musica_txt # Nome do som usado como música de fundo
uint16 msp_musica_rep # Número de repetições
intdec msp_musica_esp # Para cancelar se a duração da música for menos de 1 segundo
arqexec msp_musica_exec # ffplay reproduzindo a música de fundo
txt200 msp_som_txt.10 # Nome do som usado como efeito sonoro
uint16 msp_som_rep.10 # Número de repetições
arqexec msp_som_exec.10 # ffplay reproduzindo o efeito sonoro
arqdir msp_arqdir

func iniclasse
  criar(arg0)

func ini
  inic = 2
  msg("Telnet\n")
  se tela.proto == 0
    terminar
  fimse

func inic_exec # Mensagem de abertura
  msg("F1 mostra os endereços predefinidos\n")
  msg("F2 ativa/desativa eco das mensagens enviadas\n")
  msg("F3 desconecta\n")
  msg("F4 encerra o programa\n")
  msg("Teclas PGUP e PGDN permitem acessar o histórico do que foi digitado\n")
  msg("Para conectar como Telnet, digite t endereço porta\n")
  msg("Para conectar como Telnet seguro, digite s endereço porta\n")
  msg("Para conectar como Papovox, digite p endereço porta\n")
  msg("Exemplo: t intervox.nce.ufrj.br 1963\n")
  msg("Para tocar sons do MUD (MSP) via ffplay, digitar o nome do diretório\n")
  msg("aonde estão os arquivos sonoros após o número da porta\n")

func tela_tecla # Usuário pressionou uma tecla
  casovar arg0
  casose "UP"
  casose "DOWN"
  casose "LEFT"
  casose "RIGHT"
  casose "C_LEFT"
  casose "C_RIGHT"
  casose "HOME"
  casose "END"
    sair
  casose "PGUP"
    hist_pos.antes
    tela.texto = ""
    tela.texto = hist_pos.texto
    ret 1
  casose "PGDN"
    hist_pos.depois
    tela.texto = ""
    tela.texto = hist_pos.texto
    ret 1
  casose
    tela.linha = 0
  casofim
  ret tecla_[arg0]

func tecla_F1
  prog p
  se sock.proto == 0
    msg("Atalhos:\n")
    p.inifunc("_serv")
    enquanto p.lin
      msg("\c6" + p.texto + "\b = " + _serv:[p.texto] + "\n")
      p.depois
    efim
    msg("Digite um atalho ou o endereço seguido de espaço e porta\n")
    ret 1
  fimse

func tecla_F2
  eco = 1 - eco
  se tela.posx
    msg("\n")
  fimse
  se eco
    msg("\d1Eco ativado\b\n")
  senao
    msg("\d1Eco desativado\b\n")
  fimse
  ret 1

func tecla_F3
  se sock.proto
    sock.fechar
    msg("\d1Desconectado\b\n")
    inic = 2
    sock_musica("off")
    sock_som("off")
  senao
    msg("\d1Já está desconectado\b\n")
  fimse
  ret 1

func tecla_F4
  sock_musica("off")
  sock_som("off")
  terminar

func tela_msg # Usuário digitou alguma coisa
  hist_texto.addfim(arg0)
  hist_texto.remove(hist_texto.linhas - 50)
  hist_pos = hist_texto.fim
  casovar sock.proto
  casose "0" # Desconectado
    ret arg0 == "", nulo
    passo = 0
    txt200 linha = _serv:[arg0] ?? txtremove(arg0, "ED")
    se txtsub(linha, 3) # Tem som
      se !msp_ativo
        refvar msg1 = msp_ffplay.abrir("ffplay -version")
        se msg1
          msg("\d1Erro ao chamar o programa ffplay: " + msg1 + "\b\n")
          msg("Para reproduzir sons, é necessário instalar o programa ffplay\n")
          msg("Na versão Windows, colocar o ffplay.exe no mesmo diretório deste programa\n")
          ret
        fimse
      fimse
      msg("\d1Som ativado\b\n")
      msp_ativo = 2
      msp_diretorio = txtsub(linha, 3)
    senao  # Não tem som
      msp_ativo == 2 && (msp_ativo = 1)
    fimse
    se txt1(linha) == "s"
      proto = 1
      txt100 erro
      se (erro = sock.inissl) != ""
        msg("\d4Erro ao carregar biblioteca OpenSSL: " + erro + "\b\n")
      senao !sock.abrirssl(txtsub(linha, 1, 1), txtsub(linha, 2, 1))
        msg("\d1Erro ao conectar em " + txt2(linha) + "\b\n")
        msg("\d1Endereço inválido?\b\n")
      senao
        msg("\d1Conectando em " + txt2(linha) + "\b\n")
      fimse
      ret
    senao txt1(linha) == "t" || txt1(linha) == "p"
      proto = (txt1(linha) == "t" ? 0 : 2)
      se !sock.abrir(txtsub(linha, 1, 1), txtsub(linha, 2, 1))
        msg("\d1Erro ao conectar em " + txt2(linha) + "\b\n")
        msg("\d1Endereço inválido?\b\n")
      senao
        msg("\d1Conectando em " + txt2(linha) + "\b\n")
      fimse
    senao
      msg("Tecle t, s ou p, seguido de endereço e porta")
    fimse
    ret
  casose "1" # Conectando
    msg("\d1Conexão em progresso\b\n")
    ret
  casose # Conectado
    ret proto == 2 && passo != 2, msg("Ativando Papovox; aguarde\n")
    sock.msg(arg0 + "\n")
    eco && msg("\d4>>" + arg0 + "\b\n")
    ret
  casofim

func sock_err # Erro ao conectar
  msg("\d1Erro: " + arg0 + "\b\n")

func sock_con # Conectou
  msg("\d1Conectado\b\n")
  sock.cores = 1 # Cores somente ao receber
  se proto == 1
    msg("Assinatura SHA1 = " + sock.txtsha1 + "\n")
    msg("Assinatura MD5 = " + sock.txtmd5 + "\n")
  fimse

func sock_fechou # Conexão foi encerrada
  msg("\d1Conexão foi encerrada\b\n")
  inic = 5
  sock_musica("off")
  sock_som("off")

func sock_msg # Recebeu uma mensagem
  se !arg1
    ret msg(arg0)
  senao msp_ativo != 2
  senao txt(arg0, 0, 8) == "!!MUSIC(" && txtfim(arg0, 1) == ")"
    ret sock_musica(txt(arg0, 8, inttotal(arg0) - 9))
  senao txt(arg0, 0, 8) == "!!SOUND(" && txtfim(arg0, 1) == ")"
    ret sock_som(txt(arg0, 8, inttotal(arg0) - 9))
  fimse
  msg(arg0 + "\n")
  se proto == 2 && passo == 0 # Papovox; recebeu primeira mensagem
    passo = 1, sock.msg("papovox\n")
  senao proto == 2 && passo == 1 # Papovox; recebeu segunda mensagem
    passo = 2, sock.proto = 5
    msg("\d1Papovox conectado\b\n")
  fimse

func sock_musica # Tocar uma música de fundo
# arg0 = argumentos do comando !!MUSIC
  se arg0 == "off" || !txt1(arg0)
    msp_musica_exec.fechar
    ret
  fimse
  refvar arq1 = txt1(arg0)
  refvar arq2 = msp_arqdir.barra(msp_diretorio + "/" + arq1)
  ret txtproc("/\\-", txt(arq1, 0, 1)) >= 0 || txtproc(arq1, "..") >= 0, nulo
  uint16 pos
  int8 volume = 100
  int8 repeticoes = 1
  int8 continuar = 0
  epara pos = intsub(arg0) - 1, pos >= 1, pos--
    refvar t = txtsub(arg0, pos, 1)
    txt(t, 0, 2) == "v=" && (volume = txt(t, 2))
    txt(t, 0, 2) == "l=" && (repeticoes = txt(t, 2))
    txt(t, 0, 2) == "c=" && (continuar = txt(t, 2))
  efim
  msp_musica_rep = repeticoes
  se !continuar || txtsub(msp_musica_txt, 5, 1) != arq2 || !msp_musica_exec.aberto
    msp_musica_txt = "ffplay -autoexit -hide_banner -nodisp -nostats "
    msp_musica_txt += arq2 + " -af volume=" + volume / 100
    msp_musica_esp = 10
    msp_musica_exec.fechar
    msp_musica_exec.abrir(msp_musica_txt)
  fimse
  # msg("MÚSICA: " + arq2 + "\n")
  # msg("volume " + volume + " rep " + repeticoes + " cont " + continuar + "\n")

func msp_musica_exec_fechou
  ret msp_musica_esp || msp_musica_rep == 1, nulo
  msp_musica_rep--
  msp_musica_esp = 10
  msp_musica_exec.abrir(msp_musica_txt)

func sock_som # Tocar uma música de fundo
# arg0 = argumentos do comando !!MUSIC
  se arg0 == "off" || !txt1(arg0)
    msp_som_exec.0.fechar
    msp_som_exec.1.fechar
    msp_som_exec.2.fechar
    msp_som_exec.3.fechar
    msp_som_exec.4.fechar
    msp_som_exec.5.fechar
    msp_som_exec.6.fechar
    msp_som_exec.7.fechar
    msp_som_exec.8.fechar
    msp_som_exec.9.fechar
    ret
  fimse
  refvar arq1 = txt1(arg0)
  refvar arq2 = msp_arqdir.barra(msp_diretorio + "/" + arq1)
  ret txtproc("/\\-", txt(arq1, 0, 1)) >= 0 || txtproc(arq1, "..") >= 0, nulo
  uint16 pos
  int8 volume = 100
  int8 repeticoes = 1
  epara pos = intsub(arg0) - 1, pos >= 1, pos--
    refvar t = txtsub(arg0, pos, 1)
    txt(t, 0, 2) == "v=" && (volume = txt(t, 2))
    txt(t, 0, 2) == "l=" && (repeticoes = txt(t, 2))
  efim
  epara pos = 0, pos < 10, pos++
    sair !msp_som_exec.[pos].aberto
  efim
  se pos < 10
    msp_som_rep.[pos] = (repeticoes < 10 ? repeticoes : 10)
    msp_som_txt.[pos] = "ffplay -autoexit -hide_banner -nodisp -nostats "
    msp_som_txt.[pos] += arq2 + " -af volume=" + volume / 100
    msp_som_exec.[pos].abrir(msp_som_txt.[pos])
  fimse
  # msg("SOM: " + arq2 + "\n")
  # msg("volume " + volume + " rep " + repeticoes + " cont " + continuar + "\n")

func msp_som_exec_fechou
  ret msp_som_rep.[arg1] <= 1, nulo
  msp_som_rep.[arg1]--
  msp_som_exec.[arg1].abrir(msp_som_txt.[arg1])
