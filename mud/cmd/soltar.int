classe cmd_soltar
herda comando_comum
const txtajuda = config:animal1 ? ta1 + ta2 + ta3 + ta4 : ta1 + ta3
const ta1 = "\b\c3Soltar\b\n\
Sintaxe: SOLTAR <objeto>\n\
         SOLTAR <quantidade> <objeto>\n\
         SOLTAR <objeto> <container>\n\
         SOLTAR <quantidade> <objeto> <container>\n"
const ta2 = "         SOLTAR <número do animal>\n"
const ta3 = "Solta um objeto no chão ou em um container (uma bolsa, uma estante, etc).\n\
Para soltar tudo (até 10 objetos) tecle TUDO ao invés do objeto."
const ta4 = "\nPermite também soltar algum animal (se desfazer) que você possuir."
const posic = 5
#
const cmdsg = 0 # 0=comando soltar, 1=comando guardar
ref sala # Aonde soltar os itens
uint32 total # Quantidade de itens do mesmo tipo
txt20 mens # Parte da mensagem
txt80 mens2 # Outra parte da mensagem
int8 achou # Quantos itens achou
txt100 erro # Mensagem de erro
int8 soltar # Se pode soltar itens

func escr
  refvar perm_msg = $perm_[arg0.jogperm].item
  ret perm_msg, $mensjog.msg(perm_msg, arg0)
  listaobj l
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_soltar(arg0, arg1), nulo
  efim
  arg0.p_espera < 3 && (arg0.p_espera = 3)
# Checa soltar animal
  se !cmdsg && arg1 == intpos(arg1) && int(arg1) && config:animal1 >= arg1
    refvar r = arg0.animalnum(arg1)
    ret !r, arg0.msg("Você não possui " + arg1 + ".")
    ret r.p_soltar == 2, arg0.msg("Não é possível soltar esse animal.")
    ret soltaranimal(arg0, arg0.dono, r)
  fimse
# Obtém o objeto de onde soltar
  misc:separa(arg1) # Separa nome do objeto do nome do alvo
  se !misc:sep2 # Se não tem alvo, o alvo é a sala
    ret cmdsg, arg0.msg("Guardar aonde?")
    sala = arg0.dono
    soltar = sala.s_soltar(arg0)
    mens = ""
    se soltar == 1
      ret arg0.msg("Você não consegue soltar itens aqui.")
    senao sala.var.ini("u_") && !sala.var.u_[arg0.nome]_
      ret arg0.msg("Melhor não soltar nada aqui.")
    fimse
  senao
    soltar = 0
    sala = misc:itemtudo(arg0, misc:sep2) # Procura o alvo para o personagem arg0
    se !sala
      ret arg0.msg("Você não vê " + misc:sep2 + ".")
    senao sala.dono.s_sala && sala.dono.var.ini("u_") && !sala.dono.var.u_[arg0.nome]_
      ret arg0.msg("Melhor não soltar nada aqui.")
    senao !sala.i_aberto
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " não é container.")
    senao sala.i_aberto > 2 && !arg0.j_imortal
      ret arg0.msg(txtcopiamai(sala.descnome, "A") + " está fechad" + (sala.msexo ? "o." : \
"a."))
    fimse
    mens = " $e $a"
  fimse
  nomeobj n # Para reconhecer os itens
  n.ini(misc:sep1, misc:objmax, misc:tudo)
# Solta os itens
  achou = 0, erro = "Você não vê isso."
  epara l.addfim(arg0.dentro1), l, l.ini.remove
    continuar !l.objini.visivel(arg0) || !n.nome(l.objini.ident, l.objini.objtot)
    total = n # Quantidade de itens
    soltarobj(arg0, sala, l.objini)
    sair achou >= 10
  efim
  ret achou, nulo
# Solta moedas
  se arg0.var.z_moedas_ && sala.visivel(arg0) && n.nome("moedas", arg0.var.z_moedas_)
    ret sala.i_itens, arg0.msg("Não é possível colocar moedas em " + sala.descnome + ".")
    total = n
    ret soltarmoedas(arg0, sala)
  fimse
# Não encontrou o item
  arg0.msg(erro)

func soltaranimal
# arg0=quem está soltando, arg1=destino, arg2=animal
  listaobj e
  epara e.addfim(arg0.evento), e, e.ini.remove
    ret e.objini.cmd_soltaranim(arg0, arg1, arg2, arg0), nulo
  efim
  epara e.addfim(arg1.evento), e, e.ini.remove
    ret e.objini.cmd_soltaranim(arg0, arg1, arg2, arg1), nulo
  efim
  epara e.addfim(arg2.evento), e, e.ini.remove
    ret e.objini.cmd_soltaranim(arg0, arg1, arg2, arg2), nulo
  efim
  ret arg2.dono != arg0, nulo # Retorna se não possui mais o animal
  $mens.p(arg0, arg2)
  $mens.mvis1("$P se despede $d $a e $b vai embora.")
  apagar(arg2) # Apaga animal
  arg2.mdono(nulo) # Indica que não tem o animal
  arg0.recalc = 1 # Acerta personagem
  arg0.persobat == arg2 && (arg0.persobat = arg0)
  arg0.persoesc == arg2 && (arg0.persoesc = arg0)
  arg0.escolhebat # Escolhe um animal em condições de batalhar
  epara e.addfim(arg0.evento), e, e.ini.remove
    e.objini.cmd_soltouanim(arg0, arg1, arg2, arg0)
  efim
  epara e.addfim(arg1.evento), e, e.ini.remove
    e.objini.cmd_soltouanim(arg0, arg1, arg2, arg1)
  efim
  epara e.addfim(arg2.evento), e, e.ini.remove
    e.objini.cmd_soltouanim(arg0, arg1, arg2, arg2)
  efim

func soltarobj
# arg0=personagem, arg1=aonde soltar, arg2=item que quer soltar, total=quantidade de itens
# Faz achou+=1 se soltou o item
# Coloca mensagem de erro na variável erro se não conseguiu pegar
  se arg2 == arg1 # Soltar o objeto dentro dele mesmo
    se arg1.msexo
      erro = "Não é possível colocar " + arg1.descnome + " dentro dele mesmo."
    senao
      erro = "Não é possível colocar " + arg1.descnome + " dentro dela mesma."
    fimse
    ret
  senao arg1.i_itens && txtproc("\n" + arg1.i_itens + "\n", "\n" + txt(arg2, 2) + "\n") < \
0
    erro = "Não é possível colocar " + arg2.descnome + " em " + arg1.descnome + "."
    ret
  senao arg2.cabedentro(arg1) < total
    se !arg1.item
      erro = "Não consegue soltar tanta coisa aqui."
      ret
    fimse
    erro = arg1.descnome + "."
    casovar txtmin(txt1(erro))
    casose "o"
    casose "a"
    casose "os"
    casose "as"
      erro = "Não consegue colocar mais nada n" + txtcopiamai(erro, "aa")
      ret
    casofim
    erro = "Não consegue colocar mais nada em " + erro
    ret
  fimse
  achou++
  listaobj e
  epara e.addfim(arg0.evento), e, e.ini.remove
    ret e.objini.cmd_soltarobj(arg0, arg1, arg2, total, arg0), nulo
  efim
  epara e.addfim(arg1.evento), e, e.ini.remove
    ret e.objini.cmd_soltarobj(arg0, arg1, arg2, total, arg1), nulo
  efim
  epara e.addfim(arg2.evento), e, e.ini.remove
    ret e.objini.cmd_soltarobj(arg0, arg1, arg2, total, arg2), nulo
  efim
  $mens.p(arg0, arg1, arg2)
  mens2 = mens ? "$P coloca " : "$P solta "
  mens2 += total <= 1 ? "$o" : txt(total) + "x $o"
  ref r
  r = arg2
  casovar soltar
  casose "2"
    $mens.mvis1(mens2 + mens + ", que afunda em seguida.")
    arg2.apagar(total)
    sair
  casose "3"
    $mens.mvis1(mens2 + mens + ", que cai e some da sua vista.")
    arg2.apagar(total)
    sair
  casose "4"
    $mens.mvis1(mens2 + mens + ", que se desintegra em seguida.")
    arg2.apagar(total)
    sair
  casose
    $mens.mvis1(mens2 + mens + ".")
    r = arg2.mudadono(arg1, total)
  casofim
  epara e.addfim(arg0.evento), e, e.ini.remove
    e.objini.cmd_soltouobj(arg0, arg1, r, total, arg0)
  efim
  epara e.addfim(arg1.evento), e, e.ini.remove
    e.objini.cmd_soltouobj(arg0, arg1, r, total, arg1)
  efim
  epara e.addfim(r.evento), e, e.ini.remove
    e.objini.cmd_soltouobj(arg0, arg1, r, total, r)
  efim
  arg0.p_espera += 2

func soltarmoedas
# arg0=personagem, arg1=aonde soltar, total=quantidade de moedas
  listaobj e
  epara e.addfim(arg0.evento), e, e.ini.remove
    ret e.objini.cmd_soltarmoedas(arg0, arg1, total, arg0), nulo
  efim
  epara e.addfim(arg1.evento), e, e.ini.remove
    ret e.objini.cmd_soltarmoedas(arg0, arg1, total, arg1), nulo
  efim
  ret !total, nulo
  arg0.var.z_moedas_ -= total
  arg0.var.z_moedas_ < 0 && (arg0.var.z_moedas = "")
  arg0.p_espera += 2
  $mens.p(arg0, arg1)
  mens2 = mens ? "$P coloca " : "$P solta "
  se total == 1
    mens2 += "uma moeda"
  senao total == 2
    mens2 += "duas moedas"
  senao
    mens2 += txt(total) + " moedas"
  fimse
  casovar soltar
  casose "2"
    ret $mens.mvis1(mens2 + mens + ", que afunda em seguida.")
  casose "3"
    ret $mens.mvis1(mens2 + mens + ", que cai e some da sua vista.")
    ret
  casose "4"
    ret $mens.mvis1(mens2 + mens + ", que se desintegra em seguida.")
  casose
    $mens.mvis1(mens2 + mens + ".")
    arg1.var.z_moedas_ += total
    arg1.objmudou = 1
  casofim


classe cmd_guardar
herda cmd_soltar
const cmdsg = 1
const txtajuda = "\b\c3Guardar\b\n\
Sintaxe: GUARDAR\n\
         GUARDAR <objeto> <container>\n\
         GUARDAR <quantidade> <objeto> <container>\n\
Coloca um objeto dentro de um container (uma bolsa, uma estante, etc).\n\
Para guardar tudo (até 10 objetos) tecle TUDO ao invés do objeto."
