classe h_comando_mover_cfg
herda comando_comum
const m_impossivel = "Impossível seguir nessa direção."
const m_portafechada = "$P est$o fechad$a."
const m_itemfechado = "$O está fechad$u."
const m_espaco = "Não tem espaço para seguir nessa direção."
const m_flutuando = "Você não consegue porque não está flutuando."
const m_cansado = "Você está cansad$s demais."
const m_seguir = "Você segue $a."
const m_ignorar = "$A não quer obedecer."
const admordem = "m_impossivel m_portafechada m_itemfechado m_espaco m_flutuando\n\
m_cansado m_seguir m_ignorar"


classe comando_mover
herda comando_comum
const posic = 6 # Posição mínima para usar o comando
const m_entra1 = "$P chegou."
const m_entra2 = m_entra1
const m_entra3 = m_entra1
const m_sai1 = "$P foi embora."
const m_sai2 = m_sai1
const m_sai3 = m_sai1
const m_fugir1 = "Você fugiu."
const m_fugir2 = "$P fugiu."
const dir = ""
listaobj lseg # Para não seguir ciclicamente
int8 andou # Se conseguiu andar (deve fechar a porta)
txt300 abriu1 # Mensagem, se abriu a porta da casa
txt300 abriu2
const admordem = "m_entra1 m_entra2 m_entra3 m_entra4 m_sai1 m_sai2 m_sai3 m_sai4\n\
m_fugir1 m_fugir2"

func escr # Executa o comando
# arg0 = personagem
# arg1 = o que digitou após a direção
  $comando_mover.lseg.limpar
  $comando_mover.andou = 0
  ref sala = arg0.dono
# Anda
  txt100 dir1
  ref obj = arg0 # Personagem ou item que vai mover em uma direção
  se arg0.posicao == 6 # Sentado
    obj = arg0.poslugar.objlista
    se !obj.perso # Não é personagem
      ret !obj.i_mover, arg0.msg(arg0.erropos)
    senao obj.tseguir == 3 # Animal tem dono
      ret obj.iseguir.objlista != arg0, $mens.mp(comando_mover_cfg:m_ignorar, arg0, obj)
    senao int(obj.p_montar_tipo) < 3 # Animal não tem dono e não obedece
      ret $mens.mp(comando_mover_cfg:m_ignorar, arg0, obj)
    fimse
  fimse
  ret obj.posicao < 8, arg0.msg(arg0.erropos)
  se !arg0.jog || rand($miscfome.bebedir, $miscfome.cheio) > arg0.p_bebida
    dir1 = dir
    refvar saladest = obj.dono.dirsala(dir1, obj)
    ret !mover(obj, saladest, nulo, obj.dono.diritem(dir1, obj)), nulo
  senao # Bêbado andando em uma direção aleatória
    dir1 = txt(fugirdir(obj)) ?? dir
    refvar saladest = obj.dono.dirsala(dir1, obj)
    ret !$cmd_[dir1].mover(obj, saladest), nulo
  fimse
# Fecha a porta
  se sala.fecha_[dir1] && sala.porta_[dir1] < 2 && $comando_mover.andou
    refvar m = sala.porta_[dir1] < 2 ? "$M se $2."
    sala.mudaporta(dir1, sala.tranc_[dir1](obj) == 2 ? 3 : 2, m, m)
  fimse
# Próximo comando
  arg1 && arg0.sock.comandos.addini(arg1)

func mover # Personagem anda em uma direção
# arg0 = personagem
# arg1 = sala destino (se não for sala, não deixa prosseguir nessa direção)
# arg2 = item aonde está entrando (na sala origem) ou nulo
# arg3 = item de onde está saindo (na sala destino) ou nulo
# Retorna 1 se conseguiu mover ou 0 se não conseguiu
  refvar perm_msg = $perm_[arg0.jogperm].andar
  se perm_msg
    $mensjog.msg(perm_msg, arg0)
    ret 0
  fimse
  listaobj l
  ref s1 = arg0.dono # Sala aonde está
  debug dbg
  dbg.ini
  $comando_mover.lseg.addfim(arg0)
  abriu1 = abriu2 = ""
  se !arg1.s_sala
    $mens.mp(comando_mover_cfg:m_impossivel, arg0)
    ret 0
  senao !arg2 && s1.porta_[dir] & 3 >= 2 && !arg0.j_imortal
    ret !s1.socktot, 0
    refvar casa = $c_[s1.fechadura_[dir](arg0)]
    refvar cod = casa.chave
    se !cod
      arg0.msg($mens_porta.mens(comando_mover_cfg:m_portafechada, s1, dir))
      ret 0
    fimse
    listaitem i
    epara i = arg0.dentro1.ini, i, i.depois
      sair cod == i.obj.i_chave && i.obj.visivel(arg0)
    efim
    se !i
      arg0.msg($mens_porta.mens(comando_mover_cfg:m_portafechada, s1, dir))
      ret 0
    fimse
    casovar casa.infotaxa
    casose "2" # Casa bloqueada por falta de pagamento
      $mens.mp(config:casamsgbloq, arg0)
      ret 0
    casose "1" # Atrasou pagamento da taxa
      $mens.mp(config:casamsgaviso, arg0)
    casofim
    abriu1 = config:casaabriu1
    abriu2 = config:casaabriu2
    abriu2 && (abriu2 += "\n")
  senao arg2 && arg2.i_aberto > 2 && !arg0.j_imortal
    $mens.mp(comando_mover_cfg:m_itemfechado, arg0, nulo, arg2)
    ret 0
  senao !arg0.cabedentro(arg1)
    $mens.mp(comando_mover_cfg:m_espaco, arg0)
    ret 0
  senao !arg2 && s1.voar_[dir](arg0) && !(arg0.bitver & 512 || arg0.bitinv & 48)
    $mens.mp(comando_mover_cfg:m_flutuando, arg0)
    ret 0
  fimse
  uint8 total = s1.totalmove + arg1.totalmove
  !s1.visivel(arg0) && (total *= 2) # No escuro gasta mais movimentos
  total *= (2 + $miscfome.f.[arg0.p_sede] + $miscfome.f.[arg0.p_fome]) / 2
  (arg0.bitver & 512 || arg0.bitinv & 48) && (total /= 2) # Flutuando gasta menos movimentos
  se arg0.pmove < intdiv((total + 1) / 2)
    $mens.mp(comando_mover_cfg:m_cansado, arg0)
    ret 0
  fimse
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_mover(arg0, s1, dir, arg0, arg1, arg2, arg3), 0
  efim
  epara l.addfim(s1.evento), l, l.ini.remove
    ret l.objini.cmd_mover(arg0, s1, dir, s1, arg1, arg2, arg3), 0
  efim
  epara l.addfim(arg3.evento), l, l.ini.remove
    ret l.objini.cmd_mover(arg0, s1, dir, arg3, arg1, arg2, arg3), 0
  efim
  epara l.addfim(arg1.evento), l, l.ini.remove
    ret l.objini.cmd_moverdest(arg0, s1, dir, arg1, arg1, arg2, arg3), 0
  efim
  epara l.addfim(arg2.evento), l, l.ini.remove
    ret l.objini.cmd_moverdest(arg0, s1, dir, arg2, arg1, arg2, arg3), 0
  efim
  $comando_mover.andou = 1
  !arg0.j_imortal && (arg0.pmove -= intdiv((total + 1) / 2))
  arg0.p_espera = intmin(30, total ?? 1) * 2
  se !(s1.socktot || arg1.socktot) # Não tem jogador por perto
    arg0.mudadono(arg1)
  senao arg0.p_bebida >= $miscfome.bebedir - rand(20) # Cambaleando não anda em silêncio
    abriu1 && $mens.msgvis(abriu1, arg0)
    refvar ssai = arg0.bitinv & 0x30 ? arg0.p_som_voasai : arg0.p_som_sai
    refvar sent = arg0.bitinv & 0x30 ? arg0.p_som_voaentra : arg0.p_som_entra
    refvar msai = abriu2 + m_sai4
    refvar ment = m_entra4
    $mens.p(arg0, nulo, arg3)
    $mens.mvis2som(msai, ssai)
    arg0.mudadono(arg1)
    $mens.p(arg0, nulo, arg3)
    $mens.mvis2som(ment, sent)
  senao arg0.bitinv & 48 # Voando ou voando alto
    mover2(arg0, arg1, arg2, arg3, abriu2 + m_sai3, m_entra3)
  senao arg0.bitver & 0x200 # Flutuando
    mover2(arg0, arg1, arg2, arg3, abriu2 + m_sai2, m_entra2)
  senao # Não está voando nem flutuando
    mover2(arg0, arg1, arg2, arg3, abriu2 + m_sai1, m_entra1)
  fimse
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_moveu(arg0, s1, dir, arg0, arg1, arg2, arg3), 0
  efim
  epara l.addfim(s1.evento), l, l.ini.remove
    ret l.objini.cmd_moveu(arg0, s1, dir, s1, arg1, arg2, arg3), 0
  efim
  epara l.addfim(arg3.evento), l, l.ini.remove
    ret l.objini.cmd_moveu(arg0, s1, dir, arg3, arg1, arg2, arg3), 0
  efim
  epara l.addfim(arg1.evento), l, l.ini.remove
    ret l.objini.cmd_moveudest(arg0, s1, dir, arg1, arg1, arg2, arg3), 0
  efim
  epara l.addfim(arg2.evento), l, l.ini.remove
    ret l.objini.cmd_moveudest(arg0, s1, dir, arg2, arg1, arg2, arg3), 0
  efim
# Checa se morre ao entrar
  casovar arg1.s_morre(arg0)
  casose "1" # Morre
    sair arg0.j_imortal
    arg0.morreu
    ret 0
  casose "2" # Perde itens e dinheiro e morre
    sair arg0.j_imortal
    arg0.var.z_moedas = ""
  casose "3" # Perde itens e morre
    sair arg0.j_imortal
    epara l.addfim(arg0.dentro1, arg0.dentro2), l, l.ini.remove
      l.objini.item && !l.objini.manterperso && apagar(l.objini)
    efim
    arg0.morreu
    ret 0
  casose "4" # Perde dinheiro e morre
    sair arg0.j_imortal
    arg0.var.z_moedas = ""
    arg0.morreu
    ret 0
  casofim
# Seguir
  epara l.addfim(arg0.lseguir), l, l.ini.remove
    se l.objini.posicao < 8 || l.objini.dono != s1
    senao $comando_mover.lseg.possui(l.objini)
    senao l.objini.tseguir == 3
      mover(l.objini, arg1, arg2, arg3)
    senao arg0.visivel(l.objini) && s1.visivel(l.objini)
      $mens.mp(comando_mover_cfg:m_seguir, l.objini, arg0)
      mover(l.objini, arg1, arg2, arg3)
    fimse
  efim
  ret 1

func mover2 # Chamado por mover, para mudar de sala enviando mensagem
# arg0 = personagem
# arg1 = sala destino
# arg2 = item aonde está entrando (na sala origem) ou nulo
# arg3 = item de onde está saindo (na sala destino) ou nulo
# arg4 = mensagem saiu da sala origem
# arg5 = mensagem entrou na sala destino
# abriu1 = mensagem para o personagem
  listaobj l
  $mens.p(arg0, nulo, arg2)
  abriu1 && $mens.msgvis(abriu1, arg0)
  refvar ssai = arg0.bitinv & 0x30 ? arg0.p_som_voasai : arg0.p_som_sai
  refvar sent = arg0.bitinv & 0x30 ? arg0.p_som_voaentra : arg0.p_som_entra
  txt100 carga
  se arg0.persolugar
    l.addfim(arg0.persolugar)
    carga += " carregando " + l.objini.nome
    epara l.ini.remove, l, l.ini.remove
      carga += (l.total > 1 ? ", " : " e ") + l.objini.nome
    efim
  fimse
  se arg0.bitver & 256 # Anda em silêncio
    carga = " em silêncio" + carga
    refvar msai = txttroca(arg4, "$m", arg2 ? " $e $o" + carga : carga)
    refvar ment = txttroca(arg3 ? "$P saiu $d $o$m." : arg5, "$m", carga)
    l.addfim(arg0.dono.dentro2)
    epara l.remove(arg0), l, l.ini.remove
      l.objini.bitver & 0x1000 && $mens.msgsomvis(msai, ssai, l.objini)
    efim
    arg0.mudadono(arg1)
    $mens.p(arg0, nulo, arg3)
    l.addfim(arg0.dono.dentro2)
    epara l.remove(arg0, arg0.persolugar), l, l.ini.remove
      l.objini.bitver & 0x1000 && $mens.msgsomvis(ment, sent, l.objini)
    efim
  senao
    refvar msai = txttroca(arg4, "$m", arg2 ? " $e $o" + carga : carga)
    refvar ment = txttroca(arg3 ? "$P saiu $d $o$m." : arg5, "$m", carga)
    $mens.mvis2som(msai, ssai)
    arg0.mudadono(arg1)
    $mens.p(arg0, nulo, arg3)
    l.addfim(arg0.dono.dentro2)
    epara l.remove(arg0, arg0.persolugar), l, l.ini.remove
      $mens.msgsomvis(ment, sent, l.objini)
    efim
  fimse

func fugirdir # Obtém direção para onde pode fugir
# Entrada: arg0 = personagem
# Retorna: direção ou "" se não há para onde fugir
  refvar dono = ref(arg0.dono)
  txt100 t
  prog p
  epara p.inifunctudo(dono, "dir_"), p.lin, p.depois
    continuar !arg0.cabedentro(dono.[p.texto](arg0))
    refvar y = txt(p.texto, 4)
    !dono.fugir_[y](arg0) && int(dono.porta_[y]) < 2 && (t += y + " ")
  efim
  ret t ? txtsub(t, rand(intsub(t)), 1) : ""


classe h_cmd_n
herda comando_mover
const m_entra1 = "$P chegou do sul$m."
const m_entra2 = "$P flutuou do sul$m."
const m_entra3 = "$P voou do sul$m."
const m_entra4 = "$P chegou do sul cambaleando."
const m_sai1 = "$P foi para o norte$m."
const m_sai2 = "$P flutuou para o norte$m."
const m_sai3 = "$P voou para o norte$m."
const m_sai4 = "$P foi para o norte cambaleando."
const m_fugir1 = "Você fugiu para o norte."
const m_fugir2 = "$P fugiu para o norte."
const m_porta = "a porta norte"
const dir = "n"


classe h_cmd_s
herda comando_mover
const m_entra1 = "$P chegou do norte$m."
const m_entra2 = "$P flutuou do norte$m."
const m_entra3 = "$P voou do norte$m."
const m_entra4 = "$P chegou do norte cambaleando."
const m_sai1 = "$P foi para o sul$m."
const m_sai2 = "$P flutuou para o sul$m."
const m_sai3 = "$P voou para o sul$m."
const m_sai4 = "$P foi para o sul cambaleando."
const m_fugir1 = "Você fugiu para o sul."
const m_fugir2 = "$P fugiu para o sul."
const m_porta = "a porta sul"
const dir = "s"


classe h_cmd_l
herda comando_mover
const m_entra1 = "$P chegou do oeste$m."
const m_entra2 = "$P flutuou do oeste$m."
const m_entra3 = "$P voou do oeste$m."
const m_entra4 = "$P chegou do oeste cambaleando."
const m_sai1 = "$P foi para leste$m."
const m_sai2 = "$P flutuou para leste$m."
const m_sai3 = "$P voou para leste$m."
const m_sai4 = "$P foi para leste cambaleando."
const m_fugir1 = "Você fugiu para leste."
const m_fugir2 = "$P fugiu para leste."
const m_porta = "a porta leste"
const dir = "l"


classe h_cmd_o
herda comando_mover
const m_entra1 = "$P chegou do leste$m."
const m_entra2 = "$P flutuou do leste$m."
const m_entra3 = "$P voou do leste$m."
const m_entra4 = "$P chegou do leste cambaleando."
const m_sai1 = "$P foi para oeste$m."
const m_sai2 = "$P flutuou para oeste$m."
const m_sai3 = "$P voou para oeste$m."
const m_sai4 = "$P foi para oeste cambaleando."
const m_fugir1 = "Você fugiu para oeste."
const m_fugir2 = "$P fugiu para oeste."
const m_porta = "a porta oeste"
const dir = "o"


classe h_cmd_c
herda comando_mover
const m_entra1 = "$P chegou de baixo$m."
const m_entra2 = "$P flutuou de baixo$m."
const m_entra3 = "$P voou de baixo$m."
const m_entra4 = "$P chegou de baixo cambaleando."
const m_sai1 = "$P subiu$m."
const m_sai2 = "$P flutuou para cima$m."
const m_sai3 = "$P voou para cima$m."
const m_sai4 = "$P subiu cambaleando."
const m_fugir1 = "Você fugiu para cima."
const m_fugir2 = "$P fugiu para cima."
const m_porta = "a passagem para cima"
const dir = "c"


classe h_cmd_b
herda comando_mover
const m_entra1 = "$P chegou de cima$m."
const m_entra2 = "$P flutuou de cima$m."
const m_entra3 = "$P voou de cima$m."
const m_entra4 = "$P chegou de cima cambaleando."
const m_sai1 = "$P desceu$m."
const m_sai2 = "$P flutuou para baixo$m."
const m_sai3 = "$P voou para baixo$m."
const m_sai4 = "$P desceu cambaleando."
const m_fugir1 = "Você fugiu para cima."
const m_fugir2 = "$P fugiu para cima."
const m_porta = "a passagem para baixo"
const dir = "b"


classe h_cmd_ne
herda comando_mover
const m_entra1 = "$P chegou do sudoeste$m."
const m_entra2 = "$P flutuou do sudoeste$m."
const m_entra3 = "$P voou do sudoeste$m."
const m_entra4 = "$P chegou do sudoeste cambaleando."
const m_sai1 = "$P foi para o nordeste$m."
const m_sai2 = "$P flutuou para o nordeste$m."
const m_sai3 = "$P voou para o nordeste$m."
const m_sai4 = "$P foi para o nordeste cambaleando."
const m_fugir1 = "Você fugiu para o nordeste."
const m_fugir2 = "$P fugiu para o nordeste."
const m_porta = "a porta nordeste"
const dir = "ne"


classe h_cmd_no
herda comando_mover
const m_entra1 = "$P chegou do sudeste$m."
const m_entra2 = "$P flutuou do sudeste$m."
const m_entra3 = "$P voou do sudeste$m."
const m_entra4 = "$P chegou do sudeste cambaleando."
const m_sai1 = "$P foi para o noroeste$m."
const m_sai2 = "$P flutuou para o noroeste$m."
const m_sai3 = "$P voou para o noroeste$m."
const m_sai4 = "$P foi para o noroeste cambaleando."
const m_fugir1 = "Você fugiu para o noroeste."
const m_fugir2 = "$P fugiu para o noroeste."
const m_porta = "a porta noroeste"
const dir = "no"


classe h_cmd_se
herda comando_mover
const m_entra1 = "$P chegou do noroeste$m."
const m_entra2 = "$P flutuou do noroeste$m."
const m_entra3 = "$P voou do noroeste$m."
const m_entra4 = "$P chegou do noroeste cambaleando."
const m_sai1 = "$P foi para o sudeste$m."
const m_sai2 = "$P flutuou para o sudeste$m."
const m_sai3 = "$P voou para o sudeste$m."
const m_sai4 = "$P foi para o sudeste cambaleando."
const m_fugir1 = "Você fugiu para o sudeste."
const m_fugir2 = "$P fugiu para o sudeste."
const m_porta = "a porta sudeste"
const dir = "se"


classe h_cmd_so
herda comando_mover
const m_entra1 = "$P chegou do nordeste$m."
const m_entra2 = "$P flutuou do nordeste$m."
const m_entra3 = "$P voou do nordeste$m."
const m_entra4 = "$P chegou do nordeste cambaleando."
const m_sai1 = "$P foi para o sudoeste$m."
const m_sai2 = "$P flutuou para o sudoeste$m."
const m_sai3 = "$P voou para o sudoeste$m."
const m_sai4 = "$P foi para o sudoeste cambaleando."
const m_fugir1 = "Você fugiu para o sudoeste."
const m_fugir2 = "$P fugiu para o sudoeste."
const m_porta = "a porta sudoeste"
const dir = "so"


classe h_cmd_sair
herda comando_mover
const m_entra1 = "$P chegou de dentro$m."
const m_entra2 = "$P flutuou de dentro$m."
const m_entra3 = "$P voou de dentro$m."
const m_entra4 = "$P chegou de dentro cambaleando."
const m_sai1 = "$P saiu$m."
const m_sai2 = "$P flutuou para fora$m."
const m_sai3 = "$P voou para fora$m."
const m_sai4 = "$P saiu cambaleando."
const m_fugir1 = "Você fugiu para fora."
const m_fugir2 = "$P fugiu para fora."
const m_porta = "fora"
const dir = "sair"


classe h_cmd_entrar
herda comando_mover
const m_entra1 = "$P entrou aqui$m."
const m_entra2 = "$P flutuou de fora$m."
const m_entra3 = "$P voou de fora$m."
const m_entra4 = "$P entrou aqui cambaleando."
const m_sai1 = "$P entrou$m."
const m_sai2 = "$P entrou flutuando$m."
const m_sai3 = "$P entrou voando$m."
const m_sai4 = "$P entrou cambaleando."
const m_fugir1 = "Você fugiu entrando."
const m_fugir2 = "$P fugiu entrando."
const m_porta = "dentro"
const dir = "entrar"
const m_naover = "Você não vê $m."
const m_impossivelitem = "Não é possível entrar $e $o."
const m_impossivelporta = "Não é possível entrar $e $o por $M."
const m_fechadoporta = "A entrada $M $d $o está fechada."
const m_entradas = "$O possui as seguintes entradas:"
const m_embriaguez = "Você não consegue achar a entrada $d $o."

func escr # Executa o comando
# arg0 = personagem
# arg1 = o que digitou após a direção
  ret !arg1, comando_mover:escr(arg0, arg1)
# Obtém o item e a sala
  ref item = misc:itemdono(arg0, txt1(arg1))
  ref dest = item.i_salaentrar
  $mens.mens = arg1
  ret !item, $mens.mp(m_naover, arg0)
# Obtém a porta
  se !dest || txt2(arg1)
    listaitem i # Para verificar as salas
    int8 portas # Número de portas
    epara i = item.dentro2.ini, i, i.depois
      portas += i.obj.s_sala && i.obj.s_entrada
    efim
    se portas == 1
      epara i = item.dentro2.ini, i, i.depois
        sair i.obj.s_sala && i.obj.s_entrada
      efim
      dest = i.obj
    senao portas > 1 && txt2(arg1)
      nomeobj n
      n.ini(txt2(arg1), 1)
      epara i = item.dentro2.ini, i, i.depois
        sair i.obj.s_sala && i.obj.s_entrada && n.nome(i.obj.s_entrada, 1)
      efim
      dest = i.obj
      se !dest
        $mens.mens = txt2(arg1)
        ret $mens.mp(m_impossivelporta, arg0, nulo, item)
      senao int(dest.porta_sair) >= 2
        $mens.mens = txt2(arg1)
        ret $mens.mp(m_fechadoporta, arg0, nulo, item)
      fimse
    senao portas > 1
      $mens.mp(m_entradas, arg0, nulo, item)
      epara i = item.dentro2.ini, i, i.depois
        i.obj.s_sala && i.obj.s_entrada && arg0.msg(i.obj.s_entrada)
      efim
      ret
    fimse
  fimse
# Checa se pode entrar
  se !(dest.s_sala || dest.item && dest.dono.s_sala)
    ret $mens.mp(m_impossivelitem, arg0, nulo, item)
  senao item.i_aberto > 2 && !arg0.j_imortal
    ret $mens.mp(comando_mover_cfg:m_itemfechado, arg0, nulo, item)
  fimse
# Checa se está bêbado
  se arg0.jog && rand($miscfome.bebedir, $miscfome.cheio) <= arg0.p_bebida
    ret $mens.mp(m_embriaguez, arg0, nulo, item)
  fimse
# Entra
  $comando_mover.lseg.limpar
  $comando_mover.andou = 0
  se dest.item
    ret !mover(arg0, dest.dono, item, dest)
  senao
    ret !mover(arg0, dest, item), nulo
  fimse


classe cmd_e
herda comando_comum
const objcmd = $cmd_l.objcmd(arg0)


classe cmd_w
herda comando_comum
const objcmd = $cmd_o.objcmd(arg0)


classe cmd_nw
herda comando_comum
const objcmd = $cmd_no.objcmd(arg0)


classe cmd_sw
herda comando_comum
const objcmd = $cmd_so.objcmd(arg0)


classe cmd_cima
herda comando_comum
const objcmd = $cmd_c.objcmd(arg0)


classe cmd_baixo
herda comando_comum
const objcmd = $cmd_b.objcmd(arg0)


classe cmd_u
herda comando_comum
const objcmd = $cmd_c.objcmd(arg0)


classe cmd_d
herda comando_comum
const objcmd = $cmd_b.objcmd(arg0)


classe m_cmd_mover
herda comando_menu_cmd
#
const nome1 = "Todas as direções"
const tipo1 = "mmenu_mover_cfg--"
#
const nome2 = "Norte"
const tipo2 = "menu_mover_n--"
#
const nome3 = "Sul"
const tipo3 = "menu_mover_s--"
#
const nome4 = "Leste"
const tipo4 = "menu_mover_l--"
#
const nome5 = "Oeste"
const tipo5 = "menu_mover_o--"
#
const nome6 = "Cima"
const tipo6 = "menu_mover_c--"
#
const nome7 = "Baixo"
const tipo7 = "menu_mover_b--"
#
const nome8 = "Nordeste"
const tipo8 = "menu_mover_ne--"
#
const nome9 = "Noroeste"
const tipo9 = "menu_mover_no--"
#
const nome10 = "Sudeste"
const tipo10 = "menu_mover_se--"
#
const nome11 = "Sudoeste"
const tipo11 = "menu_mover_so--"
#
const nome12 = "Sair"
const tipo12 = "menu_mover_sair--"
#
const nome13 = "Entrar"
const tipo13 = "menu_mover_entrar--"


classe mmenu_mover_cfg
herda comando_menu
const titulo = "Todas as direções"
const menufim = "m_cmd_mover"
const colunas = 28
#
const nome1 = "Impossível"
const tipo1 = "opc_linha"
const clas1 = "comando_mover_cfg"
const vari1 = "m_impossivel"
#
const nome2 = "Porta fechada"
const tipo2 = "opc_linha"
const clas2 = "comando_mover_cfg"
const vari2 = "m_portafechada"
#
const nome3 = "Item fechado"
const tipo3 = "opc_linha"
const clas3 = "comando_mover_cfg"
const vari3 = "m_itemfechado"
#
const nome4 = "Sem espaço"
const tipo4 = "opc_linha"
const clas4 = "comando_mover_cfg"
const vari4 = "m_espaco"
#
const nome5 = "Precisa flutuar"
const tipo5 = "opc_linha"
const clas5 = "comando_mover_cfg"
const vari5 = "m_flutuando"
#
const nome6 = "Cansado"
const tipo6 = "opc_linha"
const clas6 = "comando_mover_cfg"
const vari6 = "m_cansado"
#
const nome7 = "Seguir"
const tipo7 = "opc_linha"
const clas7 = "comando_mover_cfg"
const vari7 = "m_seguir"
#
const nome8 = "Animal não obede"
const info8 = "Quando está montado em um animal"
const tipo8 = "opc_linha"
const clas8 = "comando_mover_cfg"
const vari8 = "m_ignorar"


classe menu_mover_comum
herda comando_menu
const titulo = "Mover"
const menufim = "m_cmd_mover"
const colunas = 28
#
const nome1 = "Chegou andando"
const tipo1 = "opc_linha"
const clas1 = n_classe
const vari1 = "m_entra1"
#
const nome2 = "Chegou flutuando"
const tipo2 = "opc_linha"
const clas2 = n_classe
const vari2 = "m_entra2"
#
const nome3 = "Chegou voando"
const tipo3 = "opc_linha"
const clas3 = n_classe
const vari3 = "m_entra3"
#
const nome4 = "Chegou cambaleando"
const tipo4 = "opc_linha"
const clas4 = n_classe
const vari4 = "m_entra4"
#
const nome5 = "Saiu andando"
const tipo5 = "opc_linha"
const clas5 = n_classe
const vari5 = "m_sai1"
#
const nome6 = "Saiu flutuando"
const tipo6 = "opc_linha"
const clas6 = n_classe
const vari6 = "m_sai2"
#
const nome7 = "Saiu voando"
const tipo7 = "opc_linha"
const clas7 = n_classe
const vari7 = "m_sai3"
#
const nome8 = "Saiu cambaleando"
const tipo8 = "opc_linha"
const clas8 = n_classe
const vari8 = "m_sai4"
#
const nome9 = "Fugir perso"
const tipo9 = "opc_linha"
const clas9 = n_classe
const vari9 = "m_fugir1"
#
const nome10 = "Fugir outros"
const tipo10 = "opc_linha"
const clas10 = n_classe
const vari10 = "m_fugir2"


classe menu_mover_n
herda menu_mover_comum
const titulo = "Norte"
const n_classe = "cmd_n"


classe menu_mover_s
herda menu_mover_comum
const titulo = "Sul"
const n_classe = "cmd_s"


classe menu_mover_l
herda menu_mover_comum
const titulo = "Leste"
const n_classe = "cmd_l"


classe menu_mover_o
herda menu_mover_comum
const titulo = "Oeste"
const n_classe = "cmd_o"


classe menu_mover_c
herda menu_mover_comum
const titulo = "Cima"
const n_classe = "cmd_c"


classe menu_mover_b
herda menu_mover_comum
const titulo = "Baixo"
const n_classe = "cmd_b"


classe menu_mover_ne
herda menu_mover_comum
const titulo = "Nordeste"
const n_classe = "cmd_ne"


classe menu_mover_no
herda menu_mover_comum
const titulo = "Noroeste"
const n_classe = "cmd_no"


classe menu_mover_se
herda menu_mover_comum
const titulo = "Sudeste"
const n_classe = "cmd_se"


classe menu_mover_so
herda menu_mover_comum
const titulo = "Sudoeste"
const n_classe = "cmd_so"


classe menu_mover_sair
herda menu_mover_comum
const titulo = "Sair"
const n_classe = "cmd_sair"


classe menu_mover_entrar
herda menu_mover_comum
const titulo = "Entrar"
const n_classe = "cmd_entrar"
#
const nome11 = "Sem alvo"
const tipo11 = "opc_linha"
const clas11 = n_classe
const vari11 = "m_naover"
#
const nome12 = "Impossível item"
const tipo12 = "opc_linha"
const clas12 = n_classe
const vari12 = "m_impossivelitem"
#
const nome13 = "Impossível porta"
const tipo13 = "opc_linha"
const clas13 = n_classe
const vari13 = "m_impossivelporta"
#
const nome14 = "Porta fechada"
const tipo14 = "opc_linha"
const clas14 = n_classe
const vari14 = "m_fechadoporta"
#
const nome15 = "Entradas"
const tipo15 = "opc_linha"
const clas15 = n_classe
const vari15 = "m_entradas"
#
const nome16 = "Embriagado"
const tipo16 = "opc_linha"
const clas16 = n_classe
const vari16 = "m_embriaguez"
