classe miscban1
# Para controlar endereços banidos
textotxt texto # Lista de endereços banidos
inttempo tempo
const iniclasse = !$[arg0] && criar(arg0)
const ini = texto.ler(arqban), tempo_exec
const arqban = "sav2/ban.txt"

func salvar # Salva o arquivo com os endereços banidos
  texto.salvar(arqban)

func banido # Retorna 1 se um endereço IP está banido o 0 se não está
# arg0 = endereço a verificar
  textopos pos
  txt100 lin
  int16 var
  lin = "\n" + arg0
  pos = texto.ini
  ret pos.txtproc(lin + " ") >= 0, 1
  ret pos.txtproc("\n. ") >= 0, 1
  enquanto 1
    var = txtproc(lin, ".", var) + 1
    ret !var, 0
    ret pos.txtproc(txt(lin, 0, var) + " ") >= 0, 1
  efim

func tempo_exec # Limpa a lista de endereços e acerta a variável tempo
  datahora hora
  socket sock
  debug d
  d.exec = texto.linhas * 15 + 100
  hora.agora
  refvar num = hora.numtotal # Tempo atual, em segundos
  refvar linhas = int(texto.linhas) # Quantidade de linhas antes da mudança
  exec(num, sock)
  d.ini
  linhas != texto.linhas && salvar # Se a quantidade de linhas mudou, salva

func exec # Chamado internamente por tempo_exec
# arg0 = quantos segundos se passaram desde 1/1/1
# arg1 = variável socket
  tempo = 1000000
  textopos pos
  real t2
  pos = texto.ini
  enquanto pos
    se !arg1.ipvalido(txt1(pos.texto)) && !arg1.ipvalido(txt1(pos.texto) + "0")
      pos.remove
    senao txt2(pos.texto) == "0"
      pos.depois
    senao (t2 = intpos(txt2(pos.texto)) - arg0) <= 0
      pos.remove
    senao
      pos.depois
      tempo > t2 * 10 && (tempo = t2 * 10)
    fimse
  efim


classe miscban2
herda miscban1
const arqban = "sav2/ban2.txt"
