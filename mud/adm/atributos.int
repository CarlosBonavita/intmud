classe opc_atribcomum
herda comando_adm
# Funções para mudar atributos de personagens e itens
#
real2 vatrib.120 # Atributos extraídos da função
const p_atrib_bit = 22 # A partir de que opção começam atributos de bit
const p_atrib_atk = 41 # A partir de que opção começam atributos de ataque/defesa
# Depois disso vem as opções de p_atrib_atk1, e são em porcentagem
#
const p_atrib_txtnum = "Vida\n\
Vida por nível\n\
Mana\n\
Mana por nível\n\
Movimentos\n\
Movimentos por nível\n\
Velocidade\n\
Velocidade por nível\n\
Ataque normal\n\
Ataque normal por nível\n\
Defesa normal\n\
Defesa normal por nível\n\
Ataque especial\n\
Ataque especial por nível\n\
Defesa especial\n\
Defesa especial por nível\n\
Evasão\n\
Evasão por nível\n\
Precisão\n\
Precisão por nível\n\
Carrega (gramas)\n\
Carrega (gramas) por nível"
#
const p_atrib_txtbit = "Visão noturna\n\
Pode ver invisível\n\
Pode ver oculto\n\
Pode ver voando\n\
Não pode ver voando\n\
Pode ver voando alto\n\
Não pode ver voando alto\n\
Está cego\n\
Torna invisível\n\
Torna oculto\n\
Invisível a não admin\n\
Visível no escuro\n\
Anda em silêncio\n\
Percebe andar em silêncio\n\
Está flutuando\n\
Está voando\n\
Está voando alto\n\
Está dormindo\n\
Imune a dormir"
#
const p_atrib_atk1 = "Tipos Normais\nTipos Especiais\n" + config:atknomes

func atrib2txt # Usado internamente em atrib_salvar
# arg0 e arg1 = variáveis
  ret !arg1, txt(0 + arg0) # Exemplo: 5
  ret !arg0, txt(arg1) + "*pnivel" # Exemplo: 10*pnivel
  ret arg0 < 0, txt(arg1) + "*pnivel" + txt(arg0) # Exemplo: 10*pnivel-5
  ret txt(arg1) + "*pnivel+" + txt(arg0) # Exemplo: 10*pnivel+5

func atrib_ler # Extrai os atributos de uma função para a variável vatrib
# arg0 = nome da classe
# arg1 = nome da função
  int32 x
  vatrib.limpar(100)
  epara x = p_atrib_atk - 1, x >= 0, x -= 1
    vatrib.[x] = 0
  efim
  prog p
  epara p.inilinha(arg0, arg1), p.lin, p.depois
    casovar txt1(p.texto)
    casose "pvidamax"
      atrib_ler2(p.texto, vatrib.0, vatrib.1)
      sair
    casose "pmanamax"
      atrib_ler2(p.texto, vatrib.2, vatrib.3)
      sair
    casose "pmovemax"
      atrib_ler2(p.texto, vatrib.4, vatrib.5)
      sair
    casose "pveloc1"
      atrib_ler2(p.texto, vatrib.6, vatrib.7)
      sair
    casose "atknorm"
      atrib_ler2(p.texto, vatrib.8, vatrib.9)
      sair
    casose "defnorm"
      atrib_ler2(p.texto, vatrib.10, vatrib.11)
      sair
    casose "atkesp"
      atrib_ler2(p.texto, vatrib.12, vatrib.13)
      sair
    casose "defesp"
      atrib_ler2(p.texto, vatrib.14, vatrib.15)
      sair
    casose "evasao"
      atrib_ler2(p.texto, vatrib.16, vatrib.17)
      sair
    casose "precisao"
      atrib_ler2(p.texto, vatrib.18, vatrib.19)
      sair
    casose "pesomax"
      atrib_ler2(p.texto, vatrib.20, vatrib.21)
      sair
    casose "bitver"
      se txtsub(p.texto, 3, 1) == "&" || txtsub(p.texto, 1, 1) == "&="
        x = txt(txtsub(p.texto, 2), 1)
        x & 1 && (vatrib.29 = 1) # Está cego
        x & 16 && (vatrib.26 = 1) # Não pode ver voando
        x & 32 && (vatrib.28 = 1) # Não pode ver voando alto
      senao
        x = txtsub(p.texto, 2)
        x & 2 && (vatrib.22 = 1) # Visão noturna
        x & 4 && (vatrib.23 = 1) # Pode ver invisível
        x & 8 && (vatrib.24 = 1) # Pode ver oculto
        x & 16 && (vatrib.25 = 1) # Pode ver voando
        x & 32 && (vatrib.27 = 1) # Pode ver voando alto
        x & 0x100 && (vatrib.34 = 1) # Anda em silêncio
        x & 0x1000 && (vatrib.35 = 1) # Percebe quem anda em silêncio
        x & 0x200 && (vatrib.36 = 1) # Voando ou flutuando
        x & 0x400 && (vatrib.39 = 1) # Dormindo
        x & 0x800 && (vatrib.40 = 1) # Imune a dormir
      fimse
      sair
    casose "bitinv"
      se txtsub(p.texto, 3, 1) == "&" || txtsub(p.texto, 1, 1) == "&="
        vatrib.33 = 1 # Visível no escuro
      senao
        x = txtsub(p.texto, 2)
        x & 4 && (vatrib.30 = 1) # Torna invisível
        x & 8 && (vatrib.31 = 1) # Torna oculto
        x & 16 && (vatrib.37 = 1) # Voando
        x & 32 && (vatrib.38 = 1) # Voando alto
        x & 128 && (vatrib.32 = 1) # Invisível a não admin
      fimse
      sair
    casose
      se txt(p.texto, 0, 8) == "atktipo." && txtsub(p.texto, 1, 1) == "*="
        vatrib.[int(txt(p.texto, 8)) * 2 + p_atrib_atk] = 100 * txtsub(p.texto, 2)
      senao txt(p.texto, 0, 8) == "deftipo." && txtsub(p.texto, 1, 1) == "*="
        vatrib.[int(txt(p.texto, 8)) * 2 + p_atrib_atk + 1] = 100 * txtsub(p.texto, 2)
      fimse
    casofim
  efim

func atrib_ler2 # Usado internamente em atrib_ler
# arg0 = texto do tipo "a = 5" ou "a = 10 * pnivel + 5"
# arg1 e arg2 = variáveis
  se txtsub(arg0, 3, 3) == "* pnivel -"
    arg2 = txtsub(arg0, 2, 1)
    arg1 = -1 * txtsub(arg0, 6)
  senao txtsub(arg0, 3, 2) == "* pnivel"
    arg2 = txtsub(arg0, 2, 1)
    arg1 = txtsub(arg0, 6)
  senao
    arg1 = txtsub(arg0, 2)
  fimse

func atrib_salvar # Salva os atributos em função conforme a variável vatrib
# arg0 = objeto jogsock do jogador
# arg0.var.opcclasse e arg0.var.opcvar = nomes da classe e da função
# Usa também arg0.var.opcnome e arg0.var.opcexec
  textotxt t
  t.addfim("func " + arg0.var.opcvar + " # Altera atributos do personagem")
  t.addfim("# Não alterar; função criada automaticamente")
  (vatrib.0 || vatrib.1) && t.addfim("pvidamax+=" + atrib2txt(vatrib.0, vatrib.1))
  (vatrib.2 || vatrib.3) && t.addfim("pmanamax+=" + atrib2txt(vatrib.2, vatrib.3))
  (vatrib.4 || vatrib.5) && t.addfim("pmovemax+=" + atrib2txt(vatrib.4, vatrib.5))
  (vatrib.6 || vatrib.7) && t.addfim("pveloc1+=" + atrib2txt(vatrib.6, vatrib.7))
  (vatrib.8 || vatrib.9) && t.addfim("atknorm+=" + atrib2txt(vatrib.8, vatrib.9))
  (vatrib.10 || vatrib.11) && t.addfim("defnorm+=" + atrib2txt(vatrib.10, vatrib.11))
  (vatrib.12 || vatrib.13) && t.addfim("atkesp+=" + atrib2txt(vatrib.12, vatrib.13))
  (vatrib.14 || vatrib.15) && t.addfim("defesp+=" + atrib2txt(vatrib.14, vatrib.15))
  (vatrib.16 || vatrib.17) && t.addfim("evasao+=" + atrib2txt(vatrib.16, vatrib.17))
  (vatrib.18 || vatrib.19) && t.addfim("precisao+=" + atrib2txt(vatrib.18, vatrib.19))
  (vatrib.20 || vatrib.21) && t.addfim("pesomax+=" + atrib2txt(vatrib.20, vatrib.21))
  vatrib.33 && t.addfim("bitinv &= ~2") # Visível no escuro
  se 1
    int32 x
    vatrib.26 && (x += 16) # Não pode ver voando
    vatrib.28 && (x += 32) # Não pode ver voando alto
    vatrib.29 && (x += 1) # Está cego
    x && t.addfim("bitver&=~" + x)
    x = 0
    vatrib.22 && (x += 2) # Visão noturna
    vatrib.23 && (x += 4) # Pode ver invisível
    vatrib.24 && (x += 8) # Pode ver oculto
    vatrib.25 && (x += 16) # Pode ver voando
    vatrib.27 && (x += 32) # Pode ver voando alto
    vatrib.34 && (x += 0x100) # Anda em silêncio
    vatrib.35 && (x += 0x1000) # Percebe quem anda em silêncio
    vatrib.36 && (x += 0x200) # Voando ou flutuando
    vatrib.39 && (x += 0x400) # Dormindo
    vatrib.40 && (x += 0x800) # Imune a dormir
    x && t.addfim("bitver|=" + x)
    x = 0
    vatrib.30 && (x += 4) # Torna invisível
    vatrib.31 && (x += 8) # Torna oculto
    vatrib.37 && (x += 16) # Voando
    vatrib.38 && (x += 32) # Voando alto
    vatrib.32 && (x += 128) # Invisível a não admin
    x && t.addfim("bitinv|=" + x)
  fimse
  uint16 linha
  txt100 lin
  refvar total = intsublin(p_atrib_atk1) * 2 + p_atrib_atk
  epara linha = p_atrib_atk, linha < total, linha += 2
    continuar vatrib.[linha] == 100
    refvar indice = (linha - p_atrib_atk) / 2
    lin = " # " + txtsublin(p_atrib_atk1, indice, 1)
    t.addfim("atktipo." + indice + "*=" + vatrib.[linha] / 100 + lin)
  efim
  epara linha = p_atrib_atk + 1, linha < total, linha += 2
    continuar vatrib.[linha] == 100
    refvar indice = (linha - p_atrib_atk - 1) / 2
    lin = " # " + txtsublin(p_atrib_atk1, indice, 1)
    t.addfim("deftipo." + indice + "*=" + vatrib.[linha] / 100 + lin)
  efim
# msg("----------\n" + t.ini.textolin(10000) + "\n----------")
  prog p
  refvar var = arg0.var
  se t.linhas > 2
    p.criar(var.opcclasse, t.remove(10000))
    config:salvar
    criar("admmudou", var.opcclasse, var.opcexec)
    admlog(arg0, "mudou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  senao
    p.apagar(var.opcclasse, var.opcvar)
    config:salvar
    criar("admmudou", var.opcclasse, var.opcexec)
    admlog(arg0, "apagou " + var.opcclasse + ":" + var.opcvar + " " + var.opcnome)
  fimse

func passo # Editando atributos
  uint16 linha
  linha = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    se arg0.var.opcvalido
      arg0.msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      arg0.msg("Entre com uma opção, O mostra as opções, N nenhum atributo, Z cancela")
    fimse
  senao arg1 == "n" && !arg0.var.opcvalido
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    casovar tipo
    casose "atribnum" # Atributos numéricos
      epara linha = 0, linha < p_atrib_bit, linha += 1
        vatrib.[linha] = 0
      efim
      sair
    casose "atribbit" # Atributos sim/não
      epara linha = p_atrib_bit, linha < p_atrib_atk, linha += 1
        vatrib.[linha] = 0
      efim
      sair
    casose "atribatk" # Ataques
      linha = p_atrib_atk + intsublin(p_atrib_atk1) * 2 - 2
      enquanto linha >= p_atrib_atk
        vatrib.[linha] = 100, linha -= 2
      efim
      sair
    casose "atribdef" # Defesas
      linha = p_atrib_atk + intsublin(p_atrib_atk1) * 2 - 1
      enquanto linha >= p_atrib_atk
        vatrib.[linha] = 100, linha -= 2
      efim
      sair
    casofim
    atrib_salvar(arg0)
    arg0.msg("Apagado: " + arg0.var.opcnome)
    ret passosair(arg0)
  senao arg1 == "z"
    ret passosair(arg0)
  senao txt(arg1, 0, 1) == "m" # Executa comando do MUD
    arg0.perso.teclou(txtremove(txt(arg1, 1), "E"))
  senao arg1 == "o"
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    arg0.txtmais.limpar
    arg0.txtmais.addfim("Atributos")
    textotxt t1
    textotxt t2
    txt100 lin
    casovar tipo
    casose "atribnum" # Atributos numéricos
      epara t1.addfim(p_atrib_txtnum), t1.linhas, linha += 1
        lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
        se vatrib.[linha]
          arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + vatrib.[linha] + "\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casose "atribbit" # Atributos sim/não
      epara t1.addfim(p_atrib_txtbit), t1.linhas, linha += 1
        lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
        se vatrib.[linha + p_atrib_bit]
          arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c6Sim\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casose "atribatk" # Ataques
      int16 indice
      indice = p_atrib_atk
      epara t1.addfim(p_atrib_atk1), t1.linhas, indice += 2
        linha += 1, lin = "\b\c2" + linha + (linha < 10 ? "\b. " : "\b.")
        lin += "Danos " + t1.remove
        se vatrib.[indice] != 100
          arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + vatrib.[indice] + \
"%\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casose "atribdef" # Defesas
      int16 indice
      indice = p_atrib_atk + 1
      epara t1.addfim(p_atrib_atk1), t1.linhas, indice += 2
        linha += 1, lin = "\b\c2" + linha + (linha < 10 ? "\b. " : "\b.")
        lin += "Danos " + t1.remove
        se vatrib.[indice] != 100
          arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + vatrib.[indice] + \
"%\b")
        senao
          t2.addfim(lin)
        fimse
      efim
      sair
    casofim
    t2.linhas && arg0.txtmais.addfim(t2.remove(100))
    arg0.txtmostra
  senao txt(linha) != arg1
    arg0.msg("Opção inexistente: " + txt1(arg1))
  senao !linha || linha > p_atrib_atk + intsublin(p_atrib_atk1) * 2
    arg0.msg("Opção inexistente: " + txt1(arg1))
  senao tipo == "atribnum" # Atributos numéricos
    se !linha || linha > p_atrib_bit
      arg0.msg("Opção inexistente: " + txt1(arg1))
      ret 1
    fimse
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha -= 1
    arg0.var.opcpasso2 = este
    arg0.var.opclin = linha
    arg0.msg(txtsublin(p_atrib_txtnum, linha, 1) + ": " + vatrib.[linha])
    ret $opc_atrib2.passo(arg0, "\b")
  senao tipo == "atribbit" # Atributos sim/não
    se !linha || linha > p_atrib_atk - p_atrib_bit
      arg0.msg("Opção inexistente: " + txt1(arg1))
      ret 1
    fimse
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha += p_atrib_bit - 1
    vatrib.[linha] = !vatrib.[linha]
    atrib_salvar(arg0)
    refvar lin = vatrib.[linha] ? "Sim" : "Não"
    arg0.msg(txtsublin(p_atrib_txtbit, linha - p_atrib_bit, 1) + " mudou para: " + lin)
    ret 1
  senao tipo == "atribatk" # Atributos de ataque
    se !linha || linha > intsublin(p_atrib_atk1)
      arg0.msg("Opção inexistente: " + txt1(arg1))
      ret 1
    fimse
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha -= 1
    arg0.var.opcpasso2 = este
    arg0.var.opclin = linha * 2 + p_atrib_atk
    refvar nomedano = txtsublin(p_atrib_atk1, linha, 1)
    arg0.msg("Danos " + nomedano + ": " + vatrib.[arg0.var.opclin] + "%")
    ret $opc_atrib2.passo(arg0, "\b")
  senao # Atributos de defesa
    se !linha || linha > intsublin(p_atrib_atk1)
      arg0.msg("Opção inexistente: " + txt1(arg1))
      ret 1
    fimse
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha -= 1
    arg0.var.opcpasso2 = este
    arg0.var.opclin = linha * 2 + p_atrib_atk + 1
    refvar nomedano = txtsublin(p_atrib_atk1, linha, 1)
    arg0.msg("Danos " + nomedano + ": " + vatrib.[arg0.var.opclin] + "%")
    ret $opc_atrib2.passo(arg0, "\b")
  fimse
  ret 1


classe opc_atrib2
herda opc_atribcomum
# Usado por opc_atrib; editando um atributo

func passo
  real2 num
  num = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    se arg0.var.opclin_ >= p_atrib_atk
      arg0.msg("Entre com a porcentagem, 100=danos normais, Z cancela")
    senao
      arg0.msg("Entre com a quantidade, 0=não alterar, Z cancela")
    fimse
  senao arg1 == "z"
    $[arg0.var.opcpasso2].passo(arg0, "")
    arg0.var.opcpasso2 = ""
    arg0.var.opclin = ""
  senao txt(num) != arg1
    arg0.msg("Opção inválida, entre com outra")
  senao num < 0 && arg0.var.opclin_ >= p_atrib_atk
    arg0.msg("A porcentagem não pode ser menor que zero, entre com outra")
  senao
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    vatrib.[arg0.var.opclin] = num
    atrib_salvar(arg0)
    $[arg0.var.opcpasso2].passo(arg0, "")
    arg0.var.opcpasso2 = ""
    arg0.var.opclin = ""
  fimse
  ret 1


classe opc_atribcfg
herda opc_atribcomum
# Atributos numéricos dos personagens no comando Econfig

func menu # Retorna a quantidade de atributos numéricos
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    linhas += 1
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim

func passo
  uint16 linha
  linha = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    se arg0.var.opcvalido
      arg0.msg("Entre com uma opção, O mostra as opções, Z cancela")
    senao
      arg0.msg("Entre com uma opção, O mostra as opções, N nenhum atributo, Z cancela")
    fimse
  senao arg1 == "n" && !arg0.var.opcvalido
    p.apagar(arg0.var.opcclasse, arg0.var.opcvar)
    config:salvar
    criar("admmudou", arg0.var.opcclasse, arg0.var.opcexec)
    arg0.msg("Apagado: " + arg0.var.opcnome)
    admlog(arg0, "apagou " + arg0.var.opcclasse + ":" + arg0.var.opcvar + " " + arg0.var.opcnome)
    ret passosair(arg0)
  senao arg1 == "z"
    ret passosair(arg0)
  senao txt(arg1, 0, 1) == "m" # Executa comando do MUD
    perso.teclou(txtremove(txt(arg1, 1), "E"))
  senao arg1 == "o"
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    arg0.txtmais.limpar
    arg0.txtmais.addfim("Atributos")
    textotxt t1
    txt100 lin
    epara t1.addfim(p_atrib_txtnum), t1.linhas, linha += 1
      lin = "\b\c2" + txt(linha + 1) + (linha < 9 ? "\b. " : "\b.") + t1.remove
      arg0.txtmais.addfim(txt(lin + txtesp(29), 0, 34) + ": \c3" + vatrib.[linha] + "\b")
    efim
    arg0.txtmostra
  senao txt(linha) != arg1
    arg0.msg("Opção inexistente: " + txt1(arg1))
  senao !linha || linha > p_atrib_bit
    arg0.msg("Opção inexistente: " + txt1(arg1))
  senao
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    linha -= 1
    arg0.var.opclin = linha
    arg0.msg(txtsublin(p_atrib_txtnum, linha, 1) + ": " + vatrib.[linha])
    ret $opc_atribcfg2.passo(arg0, "\b")
  fimse
  ret 1


classe opc_atribcfg2
herda opc_atribcomum
# Usado por opc_atribcfg; editando um atributo

func passo
  real2 num
  num = arg1, arg0.passo = este
  se arg1 == "" || arg1 == "\b"
    arg0.msg("Entre com a quantidade, Z cancela")
  senao arg1 == "z"
    $opc_atribcfg.passo(arg0, "")
    arg0.var.opclin = ""
  senao txt(num) != arg1
    arg0.msg("Opção inválida, entre com outra")
  senao num < 0 && arg0.var.opclin_ >= p_atrib_atk
    arg0.msg("O número não pode ser menor que zero, entre com outro")
  senao
    atrib_ler(arg0.var.opcclasse, arg0.var.opcvar)
    vatrib.[arg0.var.opclin] = num
    textotxt t
    t.addfim("func " + arg0.var.opcvar + " # Altera atributos do personagem")
    t.addfim("# Função criada automaticamente")
    t.addfim("pvidamax=" + atrib2txt(vatrib.0, vatrib.1))
    t.addfim("pmanamax=" + atrib2txt(vatrib.2, vatrib.3))
    t.addfim("pmovemax=" + atrib2txt(vatrib.4, vatrib.5))
    t.addfim("pveloc1=" + atrib2txt(vatrib.6, vatrib.7))
    t.addfim("atknorm=" + atrib2txt(vatrib.8, vatrib.9))
    t.addfim("defnorm=" + atrib2txt(vatrib.10, vatrib.11))
    t.addfim("atkesp=" + atrib2txt(vatrib.12, vatrib.13))
    t.addfim("defesp=" + atrib2txt(vatrib.14, vatrib.15))
    t.addfim("evasao=" + atrib2txt(vatrib.16, vatrib.17))
    t.addfim("precisao=" + atrib2txt(vatrib.18, vatrib.19))
    t.addfim("pesomax=" + atrib2txt(vatrib.20, vatrib.21))
    prog p
    p.criar(arg0.var.opcclasse, t.remove(10000))
    config:salvar
    criar("admmudou", arg0.var.opcclasse, arg0.var.opcexec)
    admlog(arg0, "mudou " + arg0.var.opcclasse + ":" + arg0.var.opcvar + " " + arg0.var.opcnome)
    $opc_atribcfg.passo(arg0, "")
    arg0.var.opclin = ""
    $admrecalc.exec # Para atualizar os personagens
  fimse
  ret 1


classe opc_atribnum
herda opc_atribcomum
# Atributos numéricos
const tipo = "atribnum"

func menu # Retorna a quantidade de atributos numéricos
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txtsub(p.texto, 1, 1) == "+=" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim


classe opc_atribbit
herda opc_atribcomum
# Atributos sim/não
const tipo = "atribbit"

func menu # Retorna a quantidade de atributos sim/não
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 3) == "bit" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim


classe opc_atribatk
herda opc_atribcomum
# Ataques
const tipo = "atribatk"

func menu # Retorna a quantidade de ataques
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 7) == "atktipo" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim


classe opc_atribdef
herda opc_atribcomum
# Defesas
const tipo = "atribdef"

func menu # Retorna a quantidade de defesas
# arg0=nome da classe, arg1=nome da variável
  prog p
  uint16 linhas
  epara p.inilinha(arg0, arg1) && p.depois, p.lin, p.depois
    txt(p.texto, 0, 7) == "deftipo" && (linhas += 1)
  efim
  casovar p.existe(arg0, arg1)
  casose "1" # Na própria classe
    ret linhas == 1 ? "\c61 linha\b" : "\c6" + linhas + " linhas\b"
  casose "2" # Em uma classe herdada
    ret linhas == 1 ? "<herda> \c61 linha\b" : "<herda> \c6" + linhas + " linhas\b"
  casose # Não foi definido
    ret "<nulo> \c60 linhas\b"
  casofim


classe admrecalc
# Para recalcular os atributos de todos os personagens que lutam:
# $admrecalc.exec
# Para atualizar os atributos de todos os personagens:
# $admrecalc.atuperso
# Para atualizar os atributos de todos os itens:
# $admrecalc.atuitem
#
const iniclasse = !$[arg0] && criar(arg0)

func exec
  prog p
  debug d
  ref r
  d.exec = 50000
  epara p.iniherdainv("comum_persobat"), p.lin, p.depois
    epara r = $[p.texto], r, r = objdepois(r)
      r.recalc = 1
    efim
  efim

func atuperso
  prog p
  debug d
  ref r
  d.exec = 50000
  epara p.iniherdainv("comum_perso"), p.lin, p.depois
    epara r = $[p.texto], r, r = objdepois(r)
      r.recalc = 1
    efim
  efim

func atuitem
  prog p
  debug d
  ref r
  d.exec = 50000
  epara p.iniherdainv("comum_item"), p.lin, p.depois
    epara r = $[p.texto], r, r = objdepois(r)
      r.recalc = 1
    efim
  efim
