classe adm_tipo
herda comando_adm
const txtajuda = "\b\c3Comandos para tipos de personagens (raças e classes)\b\n\
  \c2LTIPO\b     Lista tipos de personagens\n\
  \c2CTIPO\b     Cria um tipo de personagem\n\
  \c2ETIPO\b     Edita um tipo de personagem\n\
  \c2ATIPO\b     Apaga um tipo de personagem\n\
  \c2TRES\b      Edita comandos do reset de tipo"


classe adm_ltipo
herda comando_adm, comando_comum
const txtajuda = "\b\c3Ltipo\b\n\
Sintaxe: LTIPO [nome]\n\
Lista os tipos de personagens que começam com o nome especificado.\n\
Se o nome for omitido, lista todos os personagens.\n\
Nota: tipos de personagens são raça e classe."

func escr # Listar tipos
  prog p
  txt100 lin
  se !p.iniclasse("t_" + arg1)
    ret arg0.msg("\bNenhum tipo encontrado.")
  fimse
  refvar txtmais = arg0.sock.txtmais
  txtmais.limpar
  lin = "Menu raças:\n  "
  epara nulo, p.lin, p.depois
    continuar $[p.texto].menu != 1
    lin += txt(p.texto, 2) + ", " + $[p.texto].nome
    txtmais.addfim([p.texto]:t_reset ? lin + ", tres" : lin), lin = "  "
  efim
  lin = "Menu classes:\n  "
  epara p.iniclasse("t_" + arg1), p.lin, p.depois
    continuar $[p.texto].menu != 2
    lin += txt(p.texto, 2) + ", " + $[p.texto].nome
    txtmais.addfim([p.texto]:t_reset ? lin + ", tres" : lin), lin = "  "
  efim
  lin = "Menu subclasses:\n  "
  epara p.iniclasse("t_" + arg1), p.lin, p.depois
    continuar $[p.texto].menu != 3
    lin += txt(p.texto, 2) + ", " + $[p.texto].nome
    txtmais.addfim([p.texto]:t_reset ? lin + ", tres" : lin), lin = "  "
  efim
  lin = "Em nenhum menu:\n  "
  epara p.iniclasse("t_" + arg1), p.lin, p.depois
    continuar $[p.texto].menu
    lin += txt(p.texto, 2) + ", " + $[p.texto].nome
    txtmais.addfim([p.texto]:t_reset ? lin + ", tres" : lin), lin = "  "
  efim
  arg0.sock.txtmostra


classe adm_ctipo
herda comando_adm, comando_comum
const txtajuda = "\b\c3Ctipo\b\n\
Sintaxe: CTIPO <nome>\n\
Cria um tipo de personagem com o nome especificado.\n\
O nome deve ser composto de letras, mas pode ter espaços no meio.\n\
Nota: tipos de personagens são raça e classe."

func escr # Criar tipo
  prog p
  txt80 nome
  uint16 num
# Checa se digitou nome do ataque
  se arg1 == ""
    ret arg0.msg("Tecle o nome do ataque após CTIPO")
  fimse
# Checa se nome válido
  nome = txte(txtremove(arg1, EMDSA))
  se txtsepara(nome, "O+DOL,DOL+O") != nome
    ret arg0.msg("Nome inválido para tipo de personagem: " + nome)
  senao p.existe("t_" + nome)
    ret arg0.msg("Já existe o tipo: " + nome)
  fimse
# Cria tipo
  txt200 lin
  lin = "t_" + txts(nome) + "\nconfig/tipo\nherda comum_tipo"
  lin += "\nconst nome = \"" + txtcopiamai(txte(nome), "A") + "\""
  p.criar(lin)
  criar("admordena", "config/tipo")
# config:salvar
  arg0.msg("\bTipo criado: " + nome)
  admlog(arg0, "criou tipo " + nome)


classe adm_atipo
herda comando_adm, comando_comum
const txtajuda = "\b\c3Atipo\b\n\
Sintaxe: ATIPO <nome>\n\
Apaga o tipo de personagem com o nome especificado.\n\
Nota: tipos de personagens são raça e classe."

func escr # Apagar tipo
  prog p
  se arg1 == ""
    arg0.msg("Tecle um nome após ATIPO")
  senao !p.existe("t_" + arg1)
    arg0.msg("Tipo não existe: " + arg1)
  senao
    arg0.sock.tpasso = arg1
    passo(arg0.sock, "")
  fimse

func passo # Confirmar que quer apagar tipo
  arg0.passo = ""
  se arg1 == "n"
    arg0.msg("Cancelado")
  senao arg1 == "s"
    prog p
    p.apagar("t_" + arg0.tpasso)
    config:salvar
    arg0.msg("Tipo apagado: " + arg0.tpasso)
    admlog(arg0, "apagou tipo " + arg0.tpasso)
  senao
    arg0.passo = este
    arg0.msg("Apagar tipo " + arg0.tpasso + "? Tecle S ou N")
  fimse
  ret 1


classe adm_etipo
herda comando_adm, comando_comum
const txtajuda = "\b\c3Etipo\b\n\
Sintaxe: ETIPO <nome>\n\
Edita o tipo de personagem com o nome especificado.\n\
Nota: tipos de personagens são raça e classe."

func escr # Editar tipo
  prog p
  se arg1 == ""
    arg0.msg("Tecle o nome do tipo após ETIPO")
  senao !p.existe("t_" + txts(arg1))
    arg0.msg("Tipo não existe: " + arg1)
  senao
    arg0.sock.var.classe1 = "t_" + txts(txtmin(arg1))
    arg0.sock.m_menu("menu_tipo")
  fimse


classe menu_tipo
herda comando_menu
const titulo = "Tipo " + txt(var.classe1, 2)
const colunas = 25
#
const nome1 = "Texto do menu"
const tipo1 = "opc_linha"
const clas1 = var.classe1
const vari1 = "nome"
#
const nome2 = "Texto comando Quem"
const tipo2 = "opc_linha"
const clas2 = var.classe1
const vari2 = "nomequem"
#
const nome3 = "Descrição"
const info3 = "Aparece quando o jogador escolhe raça ou classe"
const tipo3 = "opc_texto"
const clas3 = var.classe1
const vari3 = "desc"
#
const nome4 = "Está no menu"
const tipo4 = "opc_opcao"
const clas4 = var.classe1
const vari4 = "menu"
const extr4 = "Nenhum menu\nRaças\nClasses\nSubclasses"
#
const nome5 = "Somente raças"
const info5 = "Se esse tipo for uma classe ou subclasse que não existe em todas as raças,\n\
escreva aqui em quais raças existe"
const tipo5 = "opc_tipos"
const clas5 = var.classe1
const vari5 = "racas"
#
const nome6 = "Somente classes"
const info6 = "Se esse tipo for uma subclasse que não existe em todas as classes,\n\
escreva aqui em quais classes existe"
const tipo6 = "opc_tipos"
const clas6 = var.classe1
const vari6 = "classes"
#
const nome7 = "Atributos números"
const tipo7 = "opc_atribnum"
const clas7 = var.classe1
const vari7 = "recalc_auto"
const exec7 = "recalc_ajusta"
#
const nome8 = "Atributos sim/não"
const tipo8 = "opc_atribbit"
const clas8 = var.classe1
const vari8 = "recalc_auto"
const exec8 = "recalc_ajusta"
#
const nome9 = "Atributos ataque"
const info9 = "Afetam os danos quando o personagem ataca alguém"
const tipo9 = "opc_atribatk"
const clas9 = var.classe1
const vari9 = "recalc_auto"
const exec9 = "recalc_ajusta"
#
const nome10 = "Atributos defesa"
const info10 = "Afetam os danos quando alguém ataca o personagem"
const tipo10 = "opc_atribdef"
const clas10 = var.classe1
const vari10 = "recalc_auto"
const exec10 = "recalc_ajusta"
#
const nome11 = "Equip posições"
const info11 = "Se não estiver vazio, são as posições aonde pode usar equipamentos"
const tipo11 = "opc_vetor"
const clas11 = var.classe1
const vari11 = "equip1"
const extr11 = config:equip_txt
#
const nome12 = "Equip adicionar"
const info12 = "Adicionar essas posições no personagem"
const tipo12 = "opc_vetor"
const clas12 = var.classe1
const vari12 = "equip2"
const extr12 = config:equip_txt
#
const nome13 = "Equip remover"
const info13 = "Remover essas posições do personagem"
const tipo13 = "opc_vetor"
const clas13 = var.classe1
const vari13 = "equip3"
const extr13 = config:equip_txt
#
const nome14 = "Nível mínimo"
const info14 = "Quando o personagem do jogador é criado ou renasce, ele vai para esse\n\
nível. Se houverem níveis diferentes na raça, classe e subclasse, é\n\
considerado somente o maior."
const tipo14 = "opc_numero"
const clas14 = var.classe1
const vari14 = "nmin"
const extr14 = "0 65535"
#
const nome15 = "Nível máximo"
const info15 = "Quando o personagem chega no nível máximo, não sobe mais de nível, mas pode\n\
renascer. Se houverem níveis diferentes na raça, classe e subclasse,\n\
é considerado somente o maior. Se os três forem 0, não renasce."
const tipo15 = "opc_numero"
const clas15 = var.classe1
const vari15 = "nmax"
const extr15 = "0 65535"
#
const nome16 = "Evolui para"
const tipo16 = "opc_tipos"
const info16 = "Os novos tipos que o personagem pode escolher no comando renascer"
const clas16 = var.classe1
const vari16 = "evoluir"
#
const nome50 = "Variáveis"
const info50 = "Só tem efeito em jogadores"
const tipo50 = "opc_linha"
const clas50 = var.classe1
const vari50 = "inivar"


classe comum_tipo
#
# Ordem que deve organizar as constantes:
const admordem = "nome nomequem menu desc racas classes equip1 equip2 equip3\n\
nmin nmax evoluir inivar"
const iniclasse = !$[arg0] && criar(arg0)

func recalc_ajusta # Ajusta variáveis quando algum atributo foi mudado
  ref r
  prog p
  recalc_ajusta2(txt2(txte(este)), p, r)

func recalc_ajusta2 # Chamado internamente por recalc_ajusta para mais eficiência
# arg0 = nome do tipo
# arg1 = variável prog
# arg2 = variável ref
  epara arg2 = $jogador, arg2, arg2 = objdepois(arg2)
    (arg2.tipo1 == arg0 || arg2.tipo2 == arg0 || arg2.tipo3 == arg0) && (arg2.recalc = 1)
  efim
  epara arg1.iniclasse("p_"), arg1.lin, arg1.depois
    epara arg2 = $[arg1.texto], arg2, arg2 = objdepois(arg2)
      (arg2.tipo1 == arg0 || arg2.tipo2 == arg0 || arg2.tipo3 == arg0) && (arg2.recalc = 1)
    efim
  efim
