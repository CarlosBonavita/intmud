classe comum_persobat
herda comum_perso
# Personagem que pode batalhar
const objmax = 1 # Quantos itens pode carregar
const tipo1 = "normal" # Tipo de personagem
# const tipo2 = "" # Segundo tipo do personagem
# const tipo3 = "" # Terceiro tipo do personagem
const p_agressivo = 1 # Ataca se atacarem
const p_atktipo = config:atk_txt # Que habilidade usar em ataques automáticos
const p_atk_alvo = config:p_atk_alvo # Alvo dos ataques
const p_exp = config:p_exp # Quantidade de experiência que dá, em porcentagem
const perso = 2 # Para identificar o tipo de personagem
const pesoadd = contr == este && !(bitinv & 48) && !(bitver & 512) # Se falso, está voando
#
sav textotxt p_hist # Histórico do personagem (quem ele matou)
sav uint32 expatual # Experiência atual
sav uint16 pnivel # Nível atual
sav int32 pvida # Pontos de vida
sav int32 pmana # Pontos de mana
sav int32 pmove # Pontos de movimento
const pvidaok = pvida > 0 # Se falso, pontos de vida estão abaixo do mínimo
int32 pvidamax # Quantidade máxima de vida
int32 pmanamax # Quantidade máxima de mana
int32 pmovemax # Quantidade máxima de movimento
int16 pveloc1 # Velocidade calculada do personagem
const pveloc = pveloc1 - int((pesoden - pesoveste) / 1500)
int32 atknorm # Quantidade de ataque normal, sem modificadores em atktipo
int32 defnorm # Quantidade de defesa normal, sem modificadores em deftipo
int32 atkesp # Quantidade de ataque especial, sem modificadores em atktipo
int32 defesp # Quantidade de defesa especial, sem modificadores em deftipo
int16 evasao # Habilidade de desviar dos golpes (thac0)
int16 precisao # Habilidade de acertar os golpes (hitroll)
int32 pesoveste # Metade do peso de tudo que está vestindo
int32 pesomax # Quanto peso consegue carregar
#
real atktipo.32 # Ataque para os diversos tipos de danos
real deftipo.32 # Defesa contra os diversos tipos de danos
# As duas primeiras variáveis do vetor são golpes normais e especiais
# 1=danos normais e 0=nenhum dano (0.5=metade dos danos, etc.)
# Vide constante config:atknomes
#
listaobj atkrec # Quem atacou esse personagem; dá experiência se perder
listaitem atkenv # Item de atkrec; atkenv.objlista = alvo do personagem
listaobj atkdiv # Para dividir experiência entre personagens que atacaram
listaobj atkbat # Para apagar objetos ao iniciar ou terminar uma batalha
inttempo atktempo # Tempo para completar um turno da batalha
uint8 atkturno # Turno da batalha, usado para decidir se encerra
real atkdanos # Quantos pontos de danos causou no alvo durante a batalha
real atkdanos1 # Usado em batalhaexp: danos totais causados pelo grupo
real atkdanos2 # Usado em batalhaexp: quantidade de personagens do grupo
inttempo p_tempoatu # Tempo para atualizar personagem
txt40 p_atacou_nome # Nome do personagem do jogador que atacou esse personagem
txt10 p_atacou_dir # De que direção atacaram esse personagem (ataque de outra sala)
intdec p_tpersegue # Quanto tempo para ir de outra sala perseguindo
const p_lembra = config:p_lembra
const p_perseguevel = config:p_perseguevel
const p_animalatk = 0

func expmax
  refvar n = args ? arg0 : pnivel
  refvar t1 = $t_[tipo1]
  refvar t2 = $t_[tipo2]
  refvar t3 = $t_[tipo3]
  real2 exp = 0 + t1.expmax_[n] + t2.expmax_[n] + t3.expmax_[n] + config:expmax_[n]
  exp += config:expmax0 + t1.expmax0 + t2.expmax0 + t3.expmax0
  exp += (config:expmax1 + t1.expmax1 + t2.expmax1 + t3.expmax1) * n
  exp += (config:expmax2 + t1.expmax2 + t2.expmax2 + t3.expmax2) * n * n
  ret int(intmax(1, exp * matpow(config:exp_renascer / 100, args ? arg1 : prenascer)))

func pnivelmax
  refvar nmax = int(intmax(t_[tipo1]:nmax, t_[tipo2]:nmax, t_[tipo3]:nmax))
  ret nmax ? nmax + config:nivel_renascer * prenascer : 0

func ini # Objeto foi criado
  comum_perso:ini(arg0, arg1, arg2, arg3, arg4)
  p_restaura = 100
  pvida = pvidamax, pmana = pmanamax, pmove = pmovemax
  persobat = este, persoesc = este

func acertapos # Acerta posição
# Se arg0 for verdadeiro, checa também se morreu (pode chamar função morreu)
# Retorna o corpo do personagem, se ele morreu e ficou o corpo
  p_imortal && pvida < pvidamax && (pvida = pvidamax) # Imortal
  !p_tempoatu && (p_tempoatu = 170) # Para atualizar o personagem
  se !pvidaok # Morto
    poslugar.remove, posicao = 0
    ret arg0 ? morreu
  fimse
  casovar intpos(pvida * 100 / pvidamax)
  casose "0"
    posicao = 1 # mortalmente ferido
    ret
  casose "1"
  casose "2"
    posicao = 2 # incapacitado
    ret
  casose "3"
    posicao = 3 # fraco
    ret
  casose
    se bitver & 1024
      posicao = 4
    senao atkenv
      posicao = 7 # lutando
    senao posicao < 4 || posicao == 7
      posicao = poslugar ? 6 : pospadr # posição padrão
    fimse
  casofim

func estadopos # Retorna texto que contém o estado atual do personagem
  ret !pvidamax, "perfeitamente saudável"
  ret !pvidaok, "está desmaiad" + (msexo2 ? "o" : "a")
  casovar intpos(intdiv(pvida * 6 / pvidamax))
  casose "0"
    ret "está à beira da morte"
  casose "1"
    ret "está sangrando bastante"
  casose "2"
    ret "está muito machucad" + (msexo2 ? "o" : "a")
  casose "3"
    ret "está bastante machucad" + (msexo2 ? "o" : "a")
  casose "4"
    ret "está um pouco machucad" + (msexo2 ? "o" : "a")
  casose "5"
    ret "possui algumas escoriações"
  casose
    ret "está perfeitamente saudável"
  casofim

func recalc_exec # Ajusta variáveis, principalmente batalha
# Checa subida de nível
  se expatual >= expmax
    refvar nmax = pnivelmax
    int8 num
    enquanto 1
      refvar max = expmax
      sair expatual < max || max <= 0 || nmax > 0 && pnivel >= nmax
      expatual -= max, pnivel++
      var.z_aulas_ += config:aulas
      ++num >= 5 && (expatual = 0)
    efim
    se num
      $mens.o_1 = txtcopiamai(descnome2, "A") + (este != contr ? " de " + contr.descnome2)
      $mens.mens = pnivel
      $mens.p(este)
      $mens.mtodos2(config:nivelmsg1, config:nivelmsg2)
      pnivel >= nmax && config:nmaxmsg && $mens.msginv(config:nmaxmsg, este)
      cmd_nivel1(este, num)
      listaobj l
      epara l.addfim(evento), l, l.ini.remove
        l.objini.cmd_nivel2(este, num)
      efim
    fimse
  fimse
# Acerta atributos básicos
  bitver = 17, bitinv = 3
  pesoveste = 0
  atktipo.limpar(1)
  deftipo.limpar(1)
# Acerta atributos conforme o tipo de personagem
  config:atribcfg, recalc1_auto
  evasao += config:atk_evasao2 * var.h_[config:atk_evasao1]
  t_[tipo1]:recalc_auto, t_[tipo2]:recalc_auto, t_[tipo3]:recalc_auto
  t_[tipo1]:recalc, t_[tipo2]:recalc, t_[tipo3]:recalc
  cmd_recalc1(este)
# Modificadores
  txt512 lin
  epara lin = var.ini("f_"), lin, lin = var.depois(lin, "f_")
    [lin]:recalc2_auto, $[lin].cmd_recalc2(este)
  efim
# Bônus conforme o que está vestindo e os efeitos
  listaitem i
  epara i = dentro2.ini, i, i.depois
    [i.obj]:recalc2_auto, i.obj.cmd_recalc2(este), pesoveste += i.obj.pesotot
  efim
  pesoveste /= 2
  epara i = evento.ini, i, i.depois
    i.obj.cmd_recalc3(este)
  efim
# Acerta atributo dormindo de bitver
  bitver & 2048 && (bitver = bitver & ~1024)
  bitver & 1024 && posicao > 4 && (posicao = 4)
  atribs_exec
  recalc = 0
# Checa se ainda pode obedecer o dono
  dono.perso && dono.animalbat
# Se for jogador, checa PNJs agressivos
  ret !jog, nulo
  epara i = dono.dentro2.ini, i, i.depois
    i.obj.p_agressivo(este) == 2 && (i.obj.p_proc = 1)
  efim

const batalhaini = contr.bat_ini_int(arg0.contr, este, arg0)
# batalhaini - Indica que atacou outro personagem (está batalhando)
# arg0 = alvo do personagem

func bat_ini_int # Chamado internamente por batalhaini
# Personagem 'arg1' de 'este' quer atacar personagem 'arg2' de 'arg0'
  ret este == arg0, nulo # Não inicia batalha contra o próprio personagem
# Se o alvo está montado neste personagem, desmonta
  arg0.poslugar.objlista == este && arg0.poslugar.remove
# Se o alvo do ataque mudou, deixa de atacar o alvo
  se atkenv.objlista != arg0
    atkenv.remove
    atkenv = arg0.atkrec.addfim(este)
    atkdiv.limpar
    atktempo = config:atktempo, atkturno = 0, atkdanos = 1
    posicao >= 4 && (posicao = 7)
  fimse
# Adiciona personagem para ganhar experiência
  atkdiv.addfim1(arg1)
# Se o alvo não está batalhando, começa a batalhar
  se !arg0.atkenv
    arg0.atkenv = atkrec.addfim(arg0)
    arg0.atkdiv.limpar
    arg0.atkdiv.addfim(arg2)
    arg0.atktempo = 1, arg0.atkturno = 0, arg0.atkdanos = 1
    arg0.posicao >= 4 && (arg0.posicao = 7)
  fimse
# Acerta variáveis
  atkturno = arg0.atkturno = 0
  !p_proc && (p_proc = 1)
  arg0.p_proc = 1 # Para gerar evento de PNJs
  jog && !arg0.jog && arg0.p_proc_batalha(este)
# Apaga eventos que só existem fora da batalha
  listaitem i
  epara i = atkbat.ini, i, i.depois
    i.obj.e_condicao == 3 && apagar(i.obj)
  efim
# Checa se pode batalhar em grupo, obtém o líder do grupo do alvo
  listaobj l
  ref r
  se p_atk_individual || arg0.p_atk_individual
    ret
  senao arg0.tseguir == 2 || arg0.tseguir == 3
    r = arg0
  senao arg0.iseguir && arg0.tseguir == 1
    r = arg0.iseguir.objlista
  fimse
# Faz o líder do outro grupo atacar se não estiver batalhando
  se !r || r.atkenv || r.dono != dono
  senao r.p_agressivo(arg0) && arg0.p_agressivo(r)
    r.atkenv = atkrec.addfim(r)
    r.atkdiv.limpar
    r.atkdiv.addfim(r.persobat)
    r.atktempo = 1, r.atkturno = 0, r.atkdanos = 1
    r.posicao >= 4 && (r.posicao = 7)
    r.p_proc = 1 # Para gerar evento de PNJs
  fimse
# Faz os outros integrantes do outro grupo atacarem se não estiverem batalhando
  epara l.addfim(r.lseguir), l, l.ini.remove
    r = l.objini
    continuar r.atkenv || r.tseguir != 1 || r.dono != dono
    continuar !r.p_agressivo(arg0) || !arg0.p_agressivo(r)
    r.atkenv = atkrec.addfim(r)
    r.atkdiv.limpar
    r.atkdiv.addfim(r.persobat)
    r.atktempo = 1, r.atkturno = 0, r.atkdanos = 1
    r.posicao >= 4 && (r.posicao = 7)
    r.p_proc = 1 # Para gerar evento de PNJs
  efim
# Faz o dono atacar se não estiver batalhando
  r = iseguir.objlista
  se !r || r.atkenv || r.dono != dono || tseguir != 3
  senao r.p_agressivo(arg0) && arg0.p_agressivo(r)
    r.atkenv = arg0.atkrec.addfim(r)
    r.atkdiv.limpar
    r.atkdiv.addfim(r.persobat)
    r.atktempo = 1, r.atkturno = 0, r.atkdanos = 1
    r.posicao >= 4 && (r.posicao = 7)
    r.p_proc = 1 # Para gerar evento de PNJs
  fimse
# Faz os animais atacarem se não estiverem batalhando
  epara l.addfim(lseguir), l, l.ini.remove
    r = l.objini
    continuar r.atkenv || r.tseguir != 3 || r.dono != dono
    continuar !r.p_agressivo(arg0) || !arg0.p_agressivo(r)
    r.atkenv = arg0.atkrec.addfim(r)
    r.atkdiv.limpar
    r.atkdiv.addfim(r.persobat)
    r.atktempo = 1, r.atkturno = 0, r.atkdanos = 1
    r.posicao >= 4 && (r.posicao = 7)
    r.p_proc = 1 # Para gerar evento de PNJs
  efim

const batalhafim = contr.bat_fim_int(arg0)
# batalhafim - Encerra a batalha
# Se arg0 for verdadeiro, checa também se morreu (pode chamar função morreu)

func bat_fim_int # Chamado internamente por batalhafim
  atkenv.remove, atktempo = 0, acertapos(arg0)
  listaitem i
  epara i = atkbat.ini, i, i.depois
    i.obj.e_condicao == 2 && apagar(i.obj)
  efim
  ref r
  enquanto atkrec.ini
    r = atkrec.objini, atkrec.ini.remove, r.atktempo = 0, r.acertapos(arg0)
    epara i = r.atkbat.ini, i, i.depois
      i.obj.e_condicao == 2 && apagar(i.obj)
    efim
  efim

func batalhaexp # Dá experiência a quem estiver atacando o personagem
# arg0 = fator do ganho de experiência
  listaobj lider # Líderes de grupos
  listaitem i # Para consultar listas
  ref r
# Remove da lista os personagens desmaiados (não ganharão experiência)
# Limpa variáveis atkdanos1 e atkdanos2 do líder do grupo
# atkdanos2=1 para a soma das experiências ganhas ser maior se atacar em equipe
  epara i = contr.atkrec.ini, i, i.obj.atkdiv ? i.depois : i.removedepois
    r = i.obj
    listaitem j
    epara j = r.atkdiv.ini, j, j.obj.pvidaok ? j.depois : j.removedepois
    efim
    r.iseguir && r.tseguir == 1 && (r = r.iseguir.objlista)
    r.atkdanos1 = 0, r.atkdanos2 = 1
    lider.addfim(r)
  efim
  lider.remove # Remove líderes repetidos
# Preenche variáveis do líder do grupo:
# atkdanos1 = quantos danos o grupo causou
# atkdanos2 = 1 + quantidade de personagens
  listaobj l # Personagens que participaram da batalha
  real2 v1 # Quantos danos foram causados ao todo
  epara i = contr.atkrec.ini, i, i.depois
    r = i.obj
    v1 += r.atkdanos, l.addfim(r.atkdiv)
    r.iseguir && r.tseguir == 1 && (r = r.iseguir.objlista)
    r.atkdanos1 += i.obj.atkdanos
    r.atkdanos2 += i.obj.atkdiv.total
  efim
# Adiciona todos os personagens dos grupos
# Desde que: não estejam batalhando, estejam na mesma sala, tenham pontos de vida
# e este personagem não luta apenas individualmente
  se !p_atk_individual
    epara nulo, lider, lider.ini.remove
      refvar p1 = lider.objini
      se !p1.atkenv && p1.dono == contr.dono && p1.persobat.pvidaok
        l.addfim(p1)
        p1.atkdiv.limpar
        p1.atkdiv.addfim(p1.persobat)
        p1.atkdanos2++
      fimse
      epara i = p1.lseguir.ini, i, i.depois
        refvar p2 = i.obj
        se p2.tseguir == 1 && !p2.atkenv && p2.dono == contr.dono && p2.persobat.pvidaok
          l.addfim(p2)
          p2.atkdiv.limpar
          p2.atkdiv.addfim(p2.persobat)
          p1.atkdanos2++ # Aumenta quantidade de personagens no personagem líder
        fimse
      efim
    efim
  fimse
# Ganha experiência
  ret !v1, nulo
  refvar exp1 = arg0 * (config:atkexp0 + pnivel * config:atkexp1) * misc:mudaexp / (2000 * \
v1)
  epara i = l.ini, i, i.depois
    r = i.obj
    v1 = pnivel - r.pnivel
    se v1 < 0 # Atacou nível mais baixo
      v1 = config:atkbexp ? intpos(1 + v1 / config:atkbexp) : 1
    senao v1 # Atacou nível mais alto
      v1 = 1 + (config:atkcexp ? intmin(1, v1 / config:atkcexp) * config:atkmaxexp / 100)
    senao # Mesmo nível
      v1 = 1
    fimse
    r.dono.perso && r.var.z_dono != r.dono.descnome && (v1 *= 1.5)
    r = r.contr, r.iseguir && r.tseguir == 1 && (r = r.iseguir.objlista)
    i.obj.ganhaexp(v1 * exp1 * p_exp(i.obj) * r.atkdanos1 / r.atkdanos2)
  efim

func ganhaexp # Personagem ganha experiência
# arg0 = experiência (se negativo perde experiência)
# arg1 = verdadeiro se não deve mostrar mensagem de ganhar XP para o jogador
  refvar exp1 = intpos(int(expatual + arg0)) - expatual
  ret !exp1, nulo
  expatual += exp1
# Mensagem de experiência ganha
  se !arg1 && exp1
    txt20 m1 = (exp1 > 0 ? "add" : "sub") + (intabs(exp1) == 1 ? "1_" : "2_")
    $mens.mens = intabs(exp1)
    $mens.mp(perso_cfg:exp_[m1][este == contr ? "perso" : "outro"], contr, este)
  fimse
# Subir de nível
  refvar nmax = pnivelmax
  expatual >= expmax && (nmax <= 0 || pnivel < nmax) && (recalc = 1)

func atkauto # Realiza um ataque automático
# arg0 = alvo do ataque
# arg1 = quanto conhece da habilidade (primeiro, segundo ou terceiro ataque)
# Retorna verdadeiro se tentou atacar
  ref obj # Objeto correspondente à habilidade
  real2 aulas # Quanto sabe da habilidade, de 0 a 1
  se iempu.obj && !iempu.obj.armamanual # Ataque com arma
    obj = $cmd_[txtsublin(config:arma_txt, iempu.obj.armatipo, 1)]
    aulas = intpos((arg1 - 1) * (var.[obj.nomevar] - 1) / 49) # Nota: 49=7*7
    refvar obj2 = $cmd_[iempu.obj.armaatk]
    obj2 && (obj = obj2)
  senao # Ataque sem arma
    obj = $cmd_[p_atktipo]
    aulas = intpos(arg1 - 1) / 14 # Primeiro ataque sai com aulas=0.5 (intermediário)
  fimse
  ret int(obj.tipoalvo) != 9, nulo # Retorna se não for ataque automático
  ret !obj.autohab2(este, aulas), nulo # Checa condições para atacar
# ret txt(obj.cmdmenu) != "ataque", nulo # Retorna se comando não é habilidade
  obj.exechab(este, arg0, aulas, pnivel) # Realiza um ataque
  ret 1

func atktempo_exec # Encerra a batalha depois de um tempo
  refvar alvo = atkenv.objlista # Personagem alvo dos ataques
  ret !alvo || alvo.dono != dono, batalhafim(1)
  atktempo = config:atktempo
  se pvida < p_fugir
# $cmd_fugir.fugir(este)
  senao persobat.atkauto(alvo.persobat, 8)
    ret !atkenv || !persobat.var.h_segundo_ataque_, nulo
    debug d
    d.ini, persobat.atkauto(alvo.persobat, persobat.var.h_segundo_ataque_)
    ret !atkenv || !persobat.var.h_terceiro_ataque_, nulo
    d.ini, persobat.atkauto(alvo.persobat, persobat.var.h_terceiro_ataque_)
    ret
  fimse
  $mens.p(este, alvo)
  casovar ++atkturno
  casose "1"
    ret
  casose "2"
    posicao >= 4 && $mens.mvis1("$P se prepara.")
    ret
  casose "3"
    atktempo = 30
    posicao >= 4 && $mens.mvis1("$P procura uma brecha.")
    ret
  casose "4"
    atktempo = 30
    posicao >= 4 && $mens.mvis1("$P encara $a.")
    ret
  casofim
  atkenv.objlista.msg("Batalha encerrada.")
  msg("Batalha encerrada.")
  batalhafim(1)

func restaurar # Restaura personagem (HP, mana, etc.)
  pmana = pmanamax, pmove = pmovemax
  se !pvidaok && dono.perso
    pvida = pvidamax
    dono.animalbat # Atualiza persobat
  senao
    pvida = pvidamax
  fimse

func morreu # Procedimentos quando morre
# arg0 = quem atacou o personagem; pode ser nulo
# Retorna o corpo do personagem, se ele morreu e ficou o corpo
  ref corpo # Corpo do personagem morto
# Checa se pode morrer
  ret p_imortal, nulo
  listaobj l
  epara l.addfim(evento), l, l.ini.remove
    ret l.objini.cmd_morrer(este, arg0, este), nulo
  efim
  epara l.addfim(arg0.evento), l, l.ini.remove
    ret l.objini.cmd_morrer(este, arg0, arg0), nulo
  efim
# Histórico
  mortes++
  se arg0.perso
    arg0.p_hist.remove(arg0.p_hist.linhas - 9)
    refvar lin = "N" + arg0.pnivel + " x " + este + "(" + nome + ") N" + pnivel
    se este == contr
      arg0.p_hist.addfim(lin)
    senao
      arg0.p_hist.addfim(lin + " de " + contr + "(" + contr.nome + ") N" + contr.pnivel)
    fimse
  fimse
# Jogador: anota no log, perde experiência e transfere jogador para outro lugar
  se jog
    listaitem litem
    epara litem = dono.dentro2.ini, litem, litem.depois
      litem.obj.var.r_[nome]_ = 0
    efim
    se !arg0.perso
      $misclog.mortes(nome + " N" + pnivel)
    senao arg0.contr.jog
      refvar lin = nome + " N" + pnivel + " por jogador " + arg0.descnome2 + " N" + arg0.pnivel
      $misclog.mortes(arg0 == arg0.contr ? lin : lin + " de " + arg0.contr.descnome2)
    senao
      refvar lin = nome + " N" + pnivel + " por " + arg0.descnome2 + " N" + arg0.pnivel
      $misclog.mortes(arg0 == arg0.contr ? lin : lin + " de " + arg0.contr.descnome2)
    fimse
    pvida = intpos(pvidamax / 2 - 10) + 2
    pmana = pmanamax / 2
    pmove = pmovemax / 2
    p_restaura = rand(100, 130)
    p_sede = intmax($miscfome.cheio / 2, p_sede)
    p_fome = intmax($miscfome.cheio / 2, p_fome)
    p_bebida = p_diges = 0
    epara litem = dentro2.ini, litem, litem.depois
      litem.obj.pvida = intpos(litem.obj.pvidamax / 2 - 10) + 2
      litem.obj.pmana = litem.obj.pmanamax / 2
      litem.obj.pmove = litem.obj.pmovemax / 2
    efim
    animalbat
    casovar config:atkmatoutipo
    casose # Quem atacou ganha experiência como ao matar um PNJ
      batalhaexp(config:atkmatouexp / 100)
      sair
    casose "1" # Transfere experiência para quem atacou
      listaitem i
      epara i = contr.atkrec.ini, i, i.depois
        i.obj.pvidaok && l.addfim(i.obj.atkdiv)
      efim
      refvar valor = expatual * config:atkmorreuexp * config:atkmatouexp / 10000
      epara i = l.ini, i, i.depois
        i.obj.ganhaexp(valor / l.total)
      efim
      l.limpar
      sair
    casose "2" # Quem atacou perde experiência
      epara l.addfim(contr.atkrec.ini), l, l.ini.remove
        continuar !l.objini.pvidaok
        l.objini.ganhaexp(l.objini.expatual * config:atkmatouexp / -100)
      efim
      sair
    casofim
    batalhafim # Encerra a batalha
    expatual *= (100 - config:atkmorreuexp) / 100
    $mens.p(este)
    $mens.mtodos2(p_morreu0, p_morreu1)
    mudadono(config:salafim)
    salvar # Salva o jogo
    indiceitem ind
    !ind.obj("un " + txt2(cnome)) && apagar(este) # Sai se o jogador já saiu
# Está no comando animal: desmaiou
  senao dono.perso
    pvida = 0
    !dono.jog && batalhaexp(1.5) # Dá experiência se não for personagem de jogador
    p_morreu2 && $mens.p(este) + $mens.mtodos1(p_morreu2)
    dono.animalbat # Atualiza persobat
# Pertence a outro personagem: desmaiou, move para o comando Animal
  senao p_animal != 1 && tseguir == 3 && iseguir.objlista
    p_morreu2 && $mens.p(este) + $mens.mtodos1(p_morreu2)
    ref r = iseguir.objlista
    pvida = 0, !r.jog && batalhaexp(1.5), batalhafim
    tseguir = 0, iseguir.remove, mudadono(r)
# Morre
  senao
    pvida = 0, batalhaexp(1), batalhafim
    $mens.p(este)
    $mens.mtodos2(p_morreu0, p_morreu1)
    apagar(este)
    se p_corpo == 4
      epara l.addfim(dentro1, dentro2), l, l.ini.remove
        l.objini.item && l.objini.mudadono(dono, l.objini.objtot)
      efim
      se arg0.jogconfig.10 && var.z_moedas
        arg0.pegamoedas(este)
      senao
        dono.var.z_moedas_ += var.z_moedas_
      fimse
    senao
      p_corpo && (corpo = criar("comum_corpo", este, p_corpo))
      corpo.var.z_moedas && arg0.jogconfig.10 && arg0.pegamoedas(corpo)
    fimse
  fimse
# Apaga efeitos
  listaitem i
  epara i = dentro2.ini, i, i.depois
    i.obj.e_condicao && apagar(i.obj)
  efim
# Gera eventos
  cmd_persomorreu(arg0, corpo)
  epara l.addfim(evento), l, l.ini.remove
    l.objini.cmd_morreu(este, arg0, este, corpo)
  efim
  epara l.addfim(arg0.evento), l, l.ini.remove
    l.objini.cmd_morreu(este, arg0, arg0, corpo)
  efim
  !jog && !dono.perso && mudadono(nulo)
# Verifica se é o último animal do dono
  dono.perso && dono.persobat == dono && dono.p_animalatk == 2 && dono.morreu(arg0)
# Retorna o corpo
  ret corpo

func pegamoedas # Pega todas as moedas do personagem arg0
  int32 moedas
  moedas = arg0.var.z_moedas_
# Pega moedas
  var.z_moedas_ += moedas
  arg0.var.z_moedas = ""
# Envia mensagem
  $mens.p(este)
  ret moedas == 1, $mens.mvis1("$P pega uma moeda.")
  $mens.mvis1("$P pega " + moedas + " moedas.")
# Obtém o líder do grupo
  refvar lider = tseguir == 2 ? este : iseguir && tseguir == 1 ? iseguir.objlista
  ret !lider, nulo # Retorna se não tem líder
# Obtém a lista de personagens do grupo
  listaobj l
  listaitem i
  lider.dono == dono && l.addfim(lider)
  epara i = lider.lseguir.ini, i, i.depois
    i.obj.tseguir == 1 && i.obj.dono == dono && l.addfim(i.obj)
  efim
# Distribui as moedas
  moedas = intdiv(moedas / l.total) # Quantas moedas para cada integrante
  ret !moedas, nulo # Retorna se não vai distribuir nenhuma moeda
  l.remove(este)
  se moedas * l.total == 1
    msg("Você dá uma moeda para o grupo.")
  senao
    msg("Você dá " + moedas * l.total + " moedas para o grupo.")
  fimse
  epara i = l.ini, i, i.depois
    var.z_moedas_ -= moedas, i.obj.var.z_moedas_ += moedas
    se moedas * l.total == 1
      i.obj.msg("Você recebe uma moeda.")
    senao
      i.obj.msg("Você recebe " + moedas + " moedas.")
    fimse
  efim

func p_proc_exec # Processar comportamento do personagem
  ret este != contr, nulo # Retorna se pertence a outro personagem
  atkenv && atkenv.objlista.dono != dono && batalhafim # Encerrar batalha
  ret atkenv && pvida < p_fugir, $cmd_fugir.fugir(este) # Tenta fugir da luta
  ret sock, nulo # Retorna se está sendo controlado por jogador
  ret p_espera, p_proc = p_espera + 1 # Checa tempo para agir
  !p_tempoatu && (p_tempoatu = 170)
# Evento do personagem
  ret tseguir != 3 && cmd_pnj_proc, nulo
# Ações do personagem
  se posicao <= 4 # Não faz nada se está dormindo
    ret
  senao p_proc_animal # Escolhe animal em condições de batalhar
    ret
  senao atkenv # Se está lutando
    p_proc = 10
    casovar p_atk_alvo
    casose "1" # Atacar qualquer um aleatoriamente
      listaitem i = atkrec.ini
      i.depois(rand(atkrec.total))
      p_proc_atacar(i.obj ?? atkenv.objlista)
      ret
    casose "2" # Atacar o personagem de menor nível
      ref r = atkenv.objlista
      listaitem i
      epara i = atkrec.ini, i, i.depois
        r.pnivel > i.obj.pnivel && (r = i.obj)
      efim
      p_proc_atacar(r)
      ret
    casose # Não mudar o alvo do ataque
      p_proc_atacar(atkenv.objlista)
      ret
    casofim
  senao tseguir == 3 || p_montar_tipo == 4 && poslugar # Se tem alguém controlando
    p_atacou_nome = ""
    ret
  senao !(p_atacou_nome || p_atacou_dir) # Se não foi atacado
  senao p_atacou_nome && (!p_proc_verjog(p_atacou_nome) || p_proc_atkjog(p_atacou_nome))
    p_atacou_nome = ""
    ret
  senao p_atacou_dir && p_atk_anda && p_proc_dir(p_atacou_dir)
    p_atacou_dir = ""
    p_tpersegue = rand(70, 130) * p_perseguevel / 100
    ret
  senao p_atacou_nome && p_persegue
    se p_tpersegue # Se não é hora de se movimentar
    senao p_proc_perseguir(p_atacou_nome) # Se conseguiu se movimentar
      p_tpersegue = rand(70, 130) * p_perseguevel / 100
    senao # Se não conseguiu se movimentar
      p_atacou_nome = ""
    fimse
    p_proc = p_tpersegue + 1
    p_atacou_dir = ""
    ret
  fimse
  p_atacou_nome = p_atacou_dir = ""
  ret p_proc_atacar(p_proc_alvo), nulo
  ret p_tmove, p_proc = p_tmove + 1 # Retorna se não é hora de se movimentar
  ret p_comecorpo && posicao >= 5 && p_proc_comecorpo, nulo
  ret p_mover && posicao == 8 && p_proc_mover, nulo
  p_mover && (p_proc = 50)

func p_proc_alvo # Obtém um jogador alvo para atacar, se for agressivo
# Retorna: arg0=alvo ou nulo se não encontrar nenhum alvo
  ret atkenv, ref(atkenv.objlista) # Alvo durante a batalha
  ret !dono.socktot, nulo # Nenhum alvo se não tem jogador na sala
  listaitem i
  listaobj l
  epara i = dono.dentro2.ini, i, i.depois
    refvar r = i.obj
    r.jog && p_agressivo(r) >= (var.r_[r.nome]_ ? 1 : 2) && r.visivel(este) && l.addfim(r)
  efim
  se l.total
    i = l.ini, i.depois(rand(l.total))
    ret ref(i.obj)
  fimse

func p_proc_atacar # Realiza um ataque
# arg0 = personagem alvo do ataque
# Retorna: 1=conseguiu atacar, 0=não conseguiu
  ret !(arg0 && dono.s_luta && persobat.pvidaok), 0
  listaobj l # Lista de habilidades e magias
  txt100 t1 # Nome da habilidade ou magia
  refvar var = persoesc.var
  epara t1 = var.ini("h_"), t1, t1 = var.depois(t1, "h_")
    refvar r = $cmd_[txt(t1, 2)]
    r.cmdmenu && 9 != r.tipoalvo && l.addfim(r)
  efim
  se !dono.s_semmagia
    epara t1 = var.ini("m_"), t1, t1 = var.depois(t1, "m_")
      refvar r = $magia_[txt(t1, 2)]
      r.cmdmenu && 9 != r.tipoalvo && l.addfim(r)
    efim
  fimse
  se l.total # Se tem algum ataque, realiza um ataque manual
    listaitem i
    i = l.ini, i.depois(rand(l.total))
    refvar obj = ref(i.obj) # Objeto que processa o ataque
    refvar aulas = intpos(persobat.var.[obj.nomevar] - 1) / 7
    ret !obj.autohab2(persobat, aulas), 0
    obj.exechab(persobat, arg0.persobat, aulas, persobat.pnivel)
    ret 1
  senao !atkenv # Ataque automático
    persobat.atkauto(arg0.persobat, 8)
    ret 1
  fimse
  ret 0

func p_proc_verjog # Retorna verdadeiro se consegue ver o jogador
# arg0 = nome do personagem do jogador
  indiceitem item
  ret item.obj("pn " + txts(txtnome(p_atacou_nome))).visivel(este)

func p_proc_atkjog # Ataca jogador se estiver na mesma sala
# arg0 = nome do personagem do jogador
# Retorna: 1=conseguiu, 0=não conseguiu atacar
  indiceitem item
  refvar objjog = item.obj("pn " + txts(txtnome(p_atacou_nome)))
  ret objjog.dono == dono, p_proc_atacar(objjog)

func p_proc_perseguir # Persegue e ataca um personagem de jogador
# arg0 = nome do personagem do jogador
# Retorna: 1=conseguiu, 0=desistiu da perseguição
  ret !arg0 || atkenv, 0
# Procura rastro (recente) do jogador nas salas vizinhas
  prog p
  refvar dono1 = ref(dono)
  refvar nomevar = "r_" + arg0 # Nome da variável
  txt100 dir # Direção a ser tomada
  int32 tempo # Tempo correspondente à direção a ser tomada
  tempo = dono.var.[nomevar]_
  epara p.inifunctudo(dono1, "dir_"), p.lin, p.depois
    refvar x = ref(dono1.[p.texto](este))
    continuar !cabedentro(x) || int(x.porta_[txt(p.texto, 4)]) >= 2
    continuar x.var.[nomevar]_ <= tempo # Rastro mais antigo
    tempo = x.var.[nomevar]_ # Anota tempo do rastro
    dir = txt(p.texto, 4) # Anota direção da sala
  efim
# Anda na direção do rastro ou desiste da perseguição
  se dir && (int(p_persegue) > 1 || dono1.dir_[dir](este).s_area == dono1.s_area)
    $cmd_[dir].escr(este)
    ret 1
  fimse
  ret 0

func p_proc_batalha # Chamado se este personagem for um PNJ sendo atacado por um jogador
# arg0 = jogador que está atacando
  p_atacou_nome = arg0.nome # Anota nome do jogador em p_atacou_nome
  p_lembra && (var.r_[arg0.nome]@ = 600 * p_lembra) # Lembra do jogador
# Pede ajuda para outros personagens
  se p_atk_ajuda
    textotxt t
    ref r
    epara t.addfim(p_atk_ajuda), t.linhas, nulo
      epara r = $p_[t.remove], r, r = objdepois(r)
        continuar r.p_atacou_nome || r.p_atacou_dir
        r.p_proc = 1
        r.p_atacou_nome = arg0.nome
      efim
    efim
  fimse

const p_proc_animal = 0 # Indica que não escolheu nenhum animal

func p_tempoatu_exec # Atualiza variáveis e salva o jogo de tempos em tempos
  refvar recup = contr.dono.s_recup(este) / 1200
  ret !(recup && pvidaok), nulo
  uint8 x
  pvida < pvidamax && (x = pvida = intmin(pvidamax, intmax(2, pvida + pvidamax * recup)))
  pmana < pmanamax && (x = pmana = intmin(pmanamax, intmax(2, pmana + pmanamax * recup)))
  pmove < pmovemax && (x = pmove = intmin(pmovemax, intmax(2, pmove + pmovemax * recup)))
  x && (p_tempoatu = 170)
  posicao < 4 && acertapos # Se estiver incapacitado, pode voltar a ficar normal


classe comum_persoanimal
herda comum_persobat
# Personagem que pode batalhar e carregar animais
const perso = 3 # Para identificar o tipo de personagem
const objmax = 15 # Quantos itens pode carregar
sav ref persobat # Personagem usado na batalha
sav ref persoesc # Personagem escolhido pelo jogador

func ini
  comum_persobat:ini(arg0, arg1, arg2, arg3, arg4)

func recalc_exec # Ajusta variáveis, principalmente batalha
  comum_persobat:recalc_exec
  animalbat

func animalbat # Escolhe um personagem em condições de lutar
  refvar a = p_animalatk
  refvar e = persoesc
  se a == 1 || a < 1 && e == este
    persobat = este
  senao (a < 2 || e != este) && e.pvidaok && e.pnivel <= pnivel + config:animal_n
    persobat = e
  senao
    listaitem i
    epara i = dentro2.ini, i, i.depois
      sair i.obj.pvidaok && i.obj.pnivel <= pnivel + config:animal_n
    efim
    persobat = i.obj ?? este
  fimse

func animalmais # Retorna quantos animais ainda pode adquirir
  uint8 x = config:animal1
  listaitem i
  epara i = dentro2.ini, i, (i.obj.perso && x--) + i.depois
  efim
  ret x

func animaltot # Retorna quantos animais possui
  uint8 x
  listaitem i
  epara i = dentro2.ini, i, (i.obj.perso && x++) + i.depois
  efim
  ret x

func animalnum # Retorna o animal a partir do número; pode retornar o próprio personagem
# arg0 = número do animal (0 = o próprio personagem)
  int8 x = arg0
  ret txt(x) != arg0, nulo
  ret !x, este
  listaitem i
  epara i = dentro2.ini, i, i.depois
    sair i.obj.perso && !--x
  efim
  ret ref(i.obj)

func animal2mais # Retorna quantos animais soltos pode adquirir
  uint8 x = 1
  listaitem i
  epara i = lseguir.ini, i, (i.obj.tseguir == 3 && x--) + i.depois
  efim
  ret x

func animal2tot # Retorna quantos animais estão soltos
  uint8 x
  listaitem i
  epara i = lseguir.ini, i, (i.obj.tseguir == 3 && x++) + i.depois
  efim
  ret x

func animal2nome # Retorna o animal a partir do nome
  listaitem i
  nomeobj n
  n.ini(arg0, 1)
  epara i = lseguir.ini, i, i.depois
    refvar r = i.obj
    ret r.tseguir == 3 && n.nome(r.var.z_ident ?? r.ident, r.objtot), ref(r)
  efim

func p_proc_animal # Escolhe um animal em condições de batalhar
# Retorna: 1=mudou de animal, 0=não mudou de animal
  se p_animalatk == 1
    persobat = este
  senao persobat == este || !persobat.pvidaok
    listaitem i
    epara i = dentro2.ini, i, i.depois
      sair i.obj.pvidaok && i.obj.pnivel <= pnivel + config:animal_n
    efim
    persobat = i.obj ?? este
  fimse
  ret persoesc == persobat, 0
  p_espera = 5
  persoesc = persobat
  $mens.p(este, persoesc)
  $mens.mvis1(persobat == este ? "$P não escolhe ninguém." : "$P escolhe $b.")
  ret 1
